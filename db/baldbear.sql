/*
Navicat MySQL Data Transfer

Source Server         : 1
Source Server Version : 50712
Source Host           : localhost:3306
Source Database       : baldbear

Target Server Type    : MYSQL
Target Server Version : 50712
File Encoding         : 65001

Date: 2023-02-06 00:28:50
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for bb_labels
-- ----------------------------
DROP TABLE IF EXISTS `bb_labels`;
CREATE TABLE `bb_labels` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `icon` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bb_labels
-- ----------------------------
INSERT INTO `bb_labels` VALUES ('1', '前端基础', 'el-icon-news');
INSERT INTO `bb_labels` VALUES ('2', '前端进阶', 'el-icon-aim');
INSERT INTO `bb_labels` VALUES ('3', '前端工程化', 'el-icon-folder-opened');
INSERT INTO `bb_labels` VALUES ('4', '服务端', 'el-icon-receiving');

-- ----------------------------
-- Table structure for bb_labels_item
-- ----------------------------
DROP TABLE IF EXISTS `bb_labels_item`;
CREATE TABLE `bb_labels_item` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `pid` int(11) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `pid` (`pid`),
  CONSTRAINT `bb_labels_item_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `bb_labels` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bb_labels_item
-- ----------------------------
INSERT INTO `bb_labels_item` VALUES ('1', '1', 'Html');
INSERT INTO `bb_labels_item` VALUES ('2', '1', 'Css');
INSERT INTO `bb_labels_item` VALUES ('3', '1', 'JavaScript');
INSERT INTO `bb_labels_item` VALUES ('4', '1', 'Vue');
INSERT INTO `bb_labels_item` VALUES ('5', '2', 'TypeScript');
INSERT INTO `bb_labels_item` VALUES ('6', '2', 'Nuxt.js');
INSERT INTO `bb_labels_item` VALUES ('7', '2', '移动端适配');
INSERT INTO `bb_labels_item` VALUES ('8', '2', '性能优化');
INSERT INTO `bb_labels_item` VALUES ('9', '2', '前端安全');
INSERT INTO `bb_labels_item` VALUES ('10', '3', 'Rollup');
INSERT INTO `bb_labels_item` VALUES ('11', '3', 'Webpack');
INSERT INTO `bb_labels_item` VALUES ('12', '3', 'Vite');
INSERT INTO `bb_labels_item` VALUES ('13', '4', 'Node.js');
INSERT INTO `bb_labels_item` VALUES ('14', '4', 'Nginx');

-- ----------------------------
-- Table structure for bb_life
-- ----------------------------
DROP TABLE IF EXISTS `bb_life`;
CREATE TABLE `bb_life` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT '',
  `md_content` text,
  `html_content` text,
  `create_date` varchar(255) DEFAULT NULL,
  `update_date` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bb_life
-- ----------------------------
INSERT INTO `bb_life` VALUES ('1', '嘴硬过后还是“阳了”', '一周时间内，我家陆续都阳了\\n今天早上还在跟我妈得瑟：“咱这免疫力，你看看你们都阳了，我还啥事没有”\\n结果当天晚上就感觉浑身上下开始不舒服，一量，39.3℃\\n现在给我唯一的体验就是：新冠不会放过任何一个嘴硬的人![IMG_124820221225204701.JPG](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F17210472-e899bdbaf42045b5.jpg&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1676054916&t=88e73645663be9075c81f5183f711a1b)', '<p>一周时间内，我家陆续都阳了<br />今天早上还在跟我妈得瑟：“咱这免疫力，你看看你们都阳了，我还啥事没有”<br />结果当天晚上就感觉浑身上下开始不舒服，一量，39.3℃<br />现在给我唯一的体验就是：新冠不会放过任何一个嘴硬的人<br /><img src=\'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F17210472-e899bdbaf42045b5.jpg&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1676054916&t=88e73645663be9075c81f5183f711a1b\' alt=\'IMG_124820221225204701.JPG\' /></p>\"', '2022-12-24 23:30:29', '2022-12-24 23:30:29');
INSERT INTO `bb_life` VALUES ('2', '2023，新的一年，新的期待', '说实话，2023是疫情以来最为期待的一年\\n不用戴口罩的正常生活逐渐离我们越来越近，大学四年的生活也在这一年慢慢走向终点\\n会有不舍，有遗憾，也会有坚定，有希望，或许会遇到更大的挑战，或许会是人生轨迹上更为重要的一站\\n![IMG_124820221225204701.JPG](https://img0.baidu.com/it/u=4120883737,1530326999&fm=253&fmt=auto&app=138&f=JPEG?w=890&h=500)', '<p>说实话，2023是疫情以来最为期待的一年</p>\\n<p>不用戴口罩的正常生活逐渐离我们越来越近，大学四年的生活也在这一年慢慢走向终点</p>\\n<p>会有不舍，有遗憾，也会有坚定，有希望，或许会遇到更大的挑战，或许会是人生轨迹上更为重要的一站</p>\\n<p><img src=\\\"https://img0.baidu.com/it/u=4120883737,1530326999&fm=253&fmt=auto&app=138&f=JPEG?w=890&h=500\\\" alt=\\\"IMG_124820221225204701.JPG\\\" /></p>\\n', '2023-01-01 00:31:11', '2023-01-01 00:31:11');
INSERT INTO `bb_life` VALUES ('3', '测试', '# 这是一个一级标题', '<h1><a id=\"_0\"></a>这是一个一级标题</h1>\n', '2023-02-04 21:46:28', '2023-02-04 21:46:28');

-- ----------------------------
-- Table structure for bb_message
-- ----------------------------
DROP TABLE IF EXISTS `bb_message`;
CREATE TABLE `bb_message` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `pid` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT '',
  `below_reply_id` int(11) DEFAULT NULL,
  `below_reply_name` varchar(255) DEFAULT '',
  `user_pic` text,
  `content` text,
  `create_date` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bb_message
-- ----------------------------
INSERT INTO `bb_message` VALUES ('1', '-1', '102', 'CPU已被占用', '-1', '', 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F202003%2F30%2F20200330091314_yNVUZ.thumb.1000_0.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1675528225&t=55dcdea633a6055501df7fba0942cceb', '来转一转', '2023-01-02 02:03:11');
INSERT INTO `bb_message` VALUES ('2', '-1', '103', '我与夏风皆过', '-1', '', 'https://img2.baidu.com/it/u=1083951767,2525250965&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '顶顶顶', '2023-01-02 06:57:51');
INSERT INTO `bb_message` VALUES ('3', '2', '104', '咸鱼鱼鱼鱼鱼鱼', '-1', '', 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202106%2F03%2F20210603173922_e6ffc.thumb.1000_0.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1675528238&t=e57179745dbf98c59b8a003ea2feba12', '顶', '2023-01-04 14:05:36');
INSERT INTO `bb_message` VALUES ('4', '2', '105', '勇敢牛牛不怕困', '-1', '', 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F201911%2F21%2F20191121195046_fktqa.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1675528416&t=c7f1a088653f2d2022527e814b32bb9a', '我也来顶', '2023-01-04 15:05:29');
INSERT INTO `bb_message` VALUES ('17', '-1', '1', '秃头熊', '-1', '', 'http://localhost:3008/static/uploads/1675240793946.jpeg', '&lt;script&gt;alert(\"1\")&lt;/script&gt;', '2023-02-05 20:27:13');

-- ----------------------------
-- Table structure for bb_notes
-- ----------------------------
DROP TABLE IF EXISTS `bb_notes`;
CREATE TABLE `bb_notes` (
  `note_id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT '',
  `summary` varchar(255) DEFAULT '',
  `label` varchar(255) DEFAULT '',
  `image_url` text,
  `view_count` int(11) unsigned DEFAULT '0',
  `chat_count` int(11) unsigned DEFAULT '0',
  `create_date` varchar(255) DEFAULT NULL,
  `update_date` varchar(255) DEFAULT NULL,
  `md_content` text,
  `html_content` text,
  PRIMARY KEY (`note_id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bb_notes
-- ----------------------------
INSERT INTO `bb_notes` VALUES ('1', '动画效果方案', '一个合理的动画是良好用户体验中必不可少的一部分。我们平常是怎样写动画的？CSS 中的 animation 和 transition，还有 requestAnimationFrame？相信大家写动画的时候心里也是在万马奔腾。今天我们来一起看看动画实现的几种方式', 'Css', 'https://img2.baidu.com/it/u=581811641,34372204&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500', '516', '0', '2022-11-04 01:35:04', '2022-11-04 01:35:10', '# 动画效果方案\\n\\n## 1. CSS3 transition\\n\\n```jsx\\ndiv{\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    width: 100px;\\n    height: 100px;\\n    background: pink;\\n    transition: all 1s ease-in-out;\\n}\\n```\\n\\n## 2. CSS3 animation\\n\\n```swift\\n// html\\n<div id=\\\"box\\\"></div>\\n// css\\ndiv{\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    width: 100px;\\n    height: 100px;\\n    background: pink;\\n    animation: move 3s infinite;\\n}\\n@keyframes move {\\n    from {\\n        left: 0;\\n    }\\n    50% {\\n        left: 400px;\\n    }\\n    to {\\n        left: 0;\\n    }\\n}\\n```\\n\\n## 3. Canvas动画\\n```js\\n    var balls = [];\\n    function loop() {\\n        ctx.fillStyle = \'#000\';\\n        ctx.fillRect(0 , 0 , XMAX, YMAX);\\n        if (balls.length < BALLCOUNT) {\\n            for(let i = BALLCOUNT; i>= balls.length;i--) {\\n                    balls.push(createBall())\\n            }\\n        }\\n \\n        balls.forEach(function (ball) {\\n            ball.update();\\n            ball.draw();\\n            ball.checkCollide();\\n        })\\n        requestAnimationFrame(loop)\\n    }\\n    loop();\\n```\\n## 4. SVG动画\\n\\n```xml\\n<svg id=\\\"box\\\" width=\\\"600\\\" height=\\\"600\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <rect width=\\\"100\\\" height=\\\"100\\\" style=\\\"fill:pink;\\\">\\n        <animate attributeName=\\\"x\\\" from=\\\"0\\\" to=\\\"400\\\" dur=\\\"3s\\\" repeatCount=\\\"indefinite\\\" />\\n    </rect>\\n</svg>\\n```\\n\\n## 5. Javascript动画-定时器\\n\\n```swift\\n// html\\n<div id=\\\"box\\\"></div>\\n// css\\n#box{\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100px;\\n    height: 100px;\\n    background: pink;\\n}\\n// js\\nlet box = document.getElementById(\'box\');\\nlet left = 0;\\nlet timer = setInterval(() => {\\n    if (left < window.innerWidth - 100) {\\n        box.style.left = left + \'px\';\\n        left ++;\\n    }else{\\n        clearInterval(timer);\\n    }\\n},16);\\n```\\n\\n## 6. requestAnimationFrame\\n\\n```dart\\n// html\\n<div id=\\\"box\\\"></div>\\n// css\\n#box{\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100px;\\n    height: 100px;\\n    background: pink;\\n}\\n// js\\nlet box = document.getElementById(\'box\');\\nlet left = 0;\\nrequestAnimationFrame(step);\\nfunction step () {\\n    if(left < window.innerWidth - 100) {\\n        left += 1;\\n        box.style.left = left + \'px\';\\n        requestAnimationFrame(step);\\n    }\\n}\\n```', '<h1><a id=\\\"_0\\\"></a>动画效果方案1</h1>\\n<h2><a id=\\\"1_CSS3_transition_2\\\"></a>1. CSS3 transition</h2>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-jsx\\\">div{\\n    <span class=\\\"hljs-attr\\\">position</span>: absolute;\\n    <span class=\\\"hljs-attr\\\">left</span>: <span class=\\\"hljs-number\\\">0</span>;\\n    <span class=\\\"hljs-attr\\\">top</span>: <span class=\\\"hljs-number\\\">0</span>;\\n    <span class=\\\"hljs-attr\\\">width</span>: 100px;\\n    <span class=\\\"hljs-attr\\\">height</span>: 100px;\\n    <span class=\\\"hljs-attr\\\">background</span>: pink;\\n    <span class=\\\"hljs-attr\\\">transition</span>: all 1s ease-<span class=\\\"hljs-keyword\\\">in</span>-out;\\n}\\n</code></div></pre>\\n<h2><a id=\\\"2_CSS3_animation_16\\\"></a>2. CSS3 animation</h2>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-swift\\\"><span class=\\\"hljs-comment\\\">// html</span>\\n<span class=\\\"hljs-operator\\\">&lt;</span>div id<span class=\\\"hljs-operator\\\">=</span><span class=\\\"hljs-string\\\">&quot;box&quot;</span><span class=\\\"hljs-operator\\\">&gt;&lt;/</span>div<span class=\\\"hljs-operator\\\">&gt;</span>\\n<span class=\\\"hljs-comment\\\">// css</span>\\ndiv{\\n    position: absolute;\\n    left: <span class=\\\"hljs-number\\\">0</span>;\\n    top: <span class=\\\"hljs-number\\\">0</span>;\\n    width: 100px;\\n    height: 100px;\\n    background: pink;\\n    animation: move 3s infinite;\\n}\\n<span class=\\\"hljs-meta\\\">@keyframes</span> move {\\n    from {\\n        left: <span class=\\\"hljs-number\\\">0</span>;\\n    }\\n    <span class=\\\"hljs-number\\\">50</span><span class=\\\"hljs-operator\\\">%</span> {\\n        left: 400px;\\n    }\\n    to {\\n        left: <span class=\\\"hljs-number\\\">0</span>;\\n    }\\n}\\n</code></div></pre>\\n<h2><a id=\\\"3_Canvas_44\\\"></a>3. Canvas动画</h2>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\">    <span class=\\\"hljs-keyword\\\">var</span> balls = [];\\n    <span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">loop</span>(<span class=\\\"hljs-params\\\"></span>) {\\n        ctx.<span class=\\\"hljs-property\\\">fillStyle</span> = <span class=\\\"hljs-string\\\">&#x27;#000&#x27;</span>;\\n        ctx.<span class=\\\"hljs-title function_\\\">fillRect</span>(<span class=\\\"hljs-number\\\">0</span> , <span class=\\\"hljs-number\\\">0</span> , <span class=\\\"hljs-variable constant_\\\">XMAX</span>, <span class=\\\"hljs-variable constant_\\\">YMAX</span>);\\n        <span class=\\\"hljs-keyword\\\">if</span> (balls.<span class=\\\"hljs-property\\\">length</span> &lt; <span class=\\\"hljs-variable constant_\\\">BALLCOUNT</span>) {\\n            <span class=\\\"hljs-keyword\\\">for</span>(<span class=\\\"hljs-keyword\\\">let</span> i = <span class=\\\"hljs-variable constant_\\\">BALLCOUNT</span>; i&gt;= balls.<span class=\\\"hljs-property\\\">length</span>;i--) {\\n                    balls.<span class=\\\"hljs-title function_\\\">push</span>(<span class=\\\"hljs-title function_\\\">createBall</span>())\\n            }\\n        }\\n \\n        balls.<span class=\\\"hljs-title function_\\\">forEach</span>(<span class=\\\"hljs-keyword\\\">function</span> (<span class=\\\"hljs-params\\\">ball</span>) {\\n            ball.<span class=\\\"hljs-title function_\\\">update</span>();\\n            ball.<span class=\\\"hljs-title function_\\\">draw</span>();\\n            ball.<span class=\\\"hljs-title function_\\\">checkCollide</span>();\\n        })\\n        <span class=\\\"hljs-title function_\\\">requestAnimationFrame</span>(loop)\\n    }\\n    <span class=\\\"hljs-title function_\\\">loop</span>();\\n</code></div></pre>\\n<h2><a id=\\\"4_SVG_65\\\"></a>4. SVG动画</h2>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-xml\\\"><span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">svg</span> <span class=\\\"hljs-attr\\\">id</span>=<span class=\\\"hljs-string\\\">&quot;box&quot;</span> <span class=\\\"hljs-attr\\\">width</span>=<span class=\\\"hljs-string\\\">&quot;600&quot;</span> <span class=\\\"hljs-attr\\\">height</span>=<span class=\\\"hljs-string\\\">&quot;600&quot;</span> <span class=\\\"hljs-attr\\\">version</span>=<span class=\\\"hljs-string\\\">&quot;1.1&quot;</span> <span class=\\\"hljs-attr\\\">xmlns</span>=<span class=\\\"hljs-string\\\">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span>\\n    <span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">rect</span> <span class=\\\"hljs-attr\\\">width</span>=<span class=\\\"hljs-string\\\">&quot;100&quot;</span> <span class=\\\"hljs-attr\\\">height</span>=<span class=\\\"hljs-string\\\">&quot;100&quot;</span> <span class=\\\"hljs-attr\\\">style</span>=<span class=\\\"hljs-string\\\">&quot;fill:pink;&quot;</span>&gt;</span>\\n        <span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">animate</span> <span class=\\\"hljs-attr\\\">attributeName</span>=<span class=\\\"hljs-string\\\">&quot;x&quot;</span> <span class=\\\"hljs-attr\\\">from</span>=<span class=\\\"hljs-string\\\">&quot;0&quot;</span> <span class=\\\"hljs-attr\\\">to</span>=<span class=\\\"hljs-string\\\">&quot;400&quot;</span> <span class=\\\"hljs-attr\\\">dur</span>=<span class=\\\"hljs-string\\\">&quot;3s&quot;</span> <span class=\\\"hljs-attr\\\">repeatCount</span>=<span class=\\\"hljs-string\\\">&quot;indefinite&quot;</span> /&gt;</span>\\n    <span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">rect</span>&gt;</span>\\n<span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">svg</span>&gt;</span>\\n</code></div></pre>\\n<h2><a id=\\\"5_Javascript_75\\\"></a>5. Javascript动画-定时器</h2>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-swift\\\"><span class=\\\"hljs-comment\\\">// html</span>\\n<span class=\\\"hljs-operator\\\">&lt;</span>div id<span class=\\\"hljs-operator\\\">=</span><span class=\\\"hljs-string\\\">&quot;box&quot;</span><span class=\\\"hljs-operator\\\">&gt;&lt;/</span>div<span class=\\\"hljs-operator\\\">&gt;</span>\\n<span class=\\\"hljs-comment\\\">// css</span>\\n#box{\\n    position: absolute;\\n    top: <span class=\\\"hljs-number\\\">0</span>;\\n    left: <span class=\\\"hljs-number\\\">0</span>;\\n    width: 100px;\\n    height: 100px;\\n    background: pink;\\n}\\n<span class=\\\"hljs-comment\\\">// js</span>\\n<span class=\\\"hljs-keyword\\\">let</span> box <span class=\\\"hljs-operator\\\">=</span> document.getElementById(&#x27;box&#x27;);\\n<span class=\\\"hljs-keyword\\\">let</span> left <span class=\\\"hljs-operator\\\">=</span> <span class=\\\"hljs-number\\\">0</span>;\\n<span class=\\\"hljs-keyword\\\">let</span> timer <span class=\\\"hljs-operator\\\">=</span> setInterval(() <span class=\\\"hljs-operator\\\">=&gt;</span> {\\n    <span class=\\\"hljs-keyword\\\">if</span> (left <span class=\\\"hljs-operator\\\">&lt;</span> window.innerWidth <span class=\\\"hljs-operator\\\">-</span> <span class=\\\"hljs-number\\\">100</span>) {\\n        box.style.left <span class=\\\"hljs-operator\\\">=</span> left <span class=\\\"hljs-operator\\\">+</span> &#x27;px&#x27;;\\n        left <span class=\\\"hljs-operator\\\">++</span>;\\n    }<span class=\\\"hljs-keyword\\\">else</span>{\\n        clearInterval(timer);\\n    }\\n},<span class=\\\"hljs-number\\\">16</span>);\\n</code></div></pre>\\n<h2><a id=\\\"6_requestAnimationFrame_102\\\"></a>6. requestAnimationFrame</h2>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-dart\\\"><span class=\\\"hljs-comment\\\">// html</span>\\n&lt;div id=<span class=\\\"hljs-string\\\">&quot;box&quot;</span>&gt;&lt;/div&gt;\\n<span class=\\\"hljs-comment\\\">// css</span>\\n#box{\\n    position: absolute;\\n    top: <span class=\\\"hljs-number\\\">0</span>;\\n    left: <span class=\\\"hljs-number\\\">0</span>;\\n    width: <span class=\\\"hljs-number\\\">100</span>px;\\n    height: <span class=\\\"hljs-number\\\">100</span>px;\\n    background: pink;\\n}\\n<span class=\\\"hljs-comment\\\">// js</span>\\nlet box = <span class=\\\"hljs-built_in\\\">document</span>.getElementById(<span class=\\\"hljs-string\\\">&#x27;box&#x27;</span>);\\nlet left = <span class=\\\"hljs-number\\\">0</span>;\\nrequestAnimationFrame(step);\\nfunction step () {\\n    <span class=\\\"hljs-keyword\\\">if</span>(left &lt; <span class=\\\"hljs-built_in\\\">window</span>.innerWidth - <span class=\\\"hljs-number\\\">100</span>) {\\n        left += <span class=\\\"hljs-number\\\">1</span>;\\n        box.style.left = left + <span class=\\\"hljs-string\\\">&#x27;px&#x27;</span>;\\n        requestAnimationFrame(step);\\n    }\\n}\\n</code></div></pre>\\n');
INSERT INTO `bb_notes` VALUES ('2', '前端跨域的几种实现方式', '跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制，也就是当两个域的协议、域名、端口号相同时，一个域下的 js 脚本才能够访问另一个域的内容，这里总结一下常见的几种跨域方式', 'JavaScript', 'https://images.quanjing.com/ph168/high/ph6585-p01862.jpg', '620', '0', '2022-11-21 07:45:10', '2022-11-21 07:45:10', '# 前端跨域的几种实现方式\\n## 什么是跨域？\\n\\n  在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能**同源**使用的限制。\\n\\n## 什么是同源策略？\\n\\n  **同源策略**是一种约定，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。\\n\\n  同源策略限制以下几种行为：\\n\\n- 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。\\n- 当前域下的 js 脚本不能够操作访问其他域下的 DOM。\\n- 当前域下 ajax 无法发送跨域请求。\\n\\nscript、image、iframe的src都不受同源策略的影响\\n\\n\\n## 1、JSONP跨域\\n\\n  **jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。\\n\\njsonp的缺点：只能发送get一种请求。\\n\\n1）原生JS实现：\\n\\n```js\\n <script>\\n    var script = document.createElement(\'script\');\\n    script.type = \'text/javascript\';\\n \\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\\n    script.src = \'http://www.domain2.com:8080/login?user=admin&callback=handleCallback\';\\n    document.head.appendChild(script);\\n \\n    // 回调执行函数\\n    function handleCallback(res) {\\n        alert(JSON.stringify(res));\\n    }\\n </script>\\n \\n 服务端返回如下（返回时即执行全局函数）：\\n handleCallback({\\\"success\\\": true, \\\"user\\\": \\\"admin\\\"})\\n\\n```\\n\\n2.Vue axios实现：\\n\\n```js\\nthis.$http = axios;\\nthis.$http.jsonp(\'http://www.domain2.com:8080/login\', {\\n    params: {},\\n    jsonp: \'handleCallback\'\\n}).then((res) => {\\n    console.log(res); \\n})\\n```\\n\\n后端代码 node.js\\n\\n```js\\nvar querystring = require(\'querystring\');\\nvar http = require(\'http\');\\nvar server = http.createServer();\\n \\nserver.on(\'request\', function(req, res) {\\n    var params = querystring.parse(req.url.split(\'?\')[1]);\\n    var fn = params.callback;\\n \\n    // jsonp返回设置\\n    res.writeHead(200, { \'Content-Type\': \'text/javascript\' });\\n    res.write(fn + \'(\' + JSON.stringify(params) + \')\');\\n \\n    res.end();\\n});\\n \\nserver.listen(\'8080\');\\nconsole.log(\'Server is running at port 8080...\');\\n```\\n\\n## 2、跨域资源共享（CORS）\\n\\n  **CORS**是一个W3C标准，全称是\\\"跨域资源共享\\\"（Cross-origin resource sharing）。\\n它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。\\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\\n\\n浏览器将CORS跨域请求分为简单请求和非简单请求。\\n\\n只要同时满足一下两个条件，就属于简单请求\\n\\n(1)使用下列方法之一：\\n\\n- head\\n- get\\n- post\\n\\n(2)请求的Heder是\\n\\n- Accept\\n- Accept-Language\\n- Content-Language\\n- Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain\\n\\n不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。\\n\\n###### 简单请求\\n\\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。\\n\\n```\\nGET /cors HTTP/1.1\\nOrigin: http://api.bob.com\\nHost: api.alice.com\\nAccept-Language: en-US\\nConnection: keep-alive\\nUser-Agent: Mozilla/5.0...\\n```\\n\\n上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\\n\\nCORS请求设置的响应头字段，都以 Access-Control-开头:\\n\\n**1）Access-Control-Allow-Origin**：必选\\n\\n  它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\\n\\n**2）Access-Control-Allow-Credentials**：可选\\n\\n  它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。\\n\\n**3）Access-Control-Expose-Headers**：可选\\n\\n  CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。\\n\\n###### 非简单请求\\n\\n  非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\\\"预检\\\"请求（preflight）。\\n\\n预检请求\\n\\n  预检\\\"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，\\\"预检\\\"请求的头信息包括两个特殊字段。\\n\\n```\\nOPTIONS /cors HTTP/1.1\\nOrigin: http://api.bob.com\\nAccess-Control-Request-Method: PUT\\nAccess-Control-Request-Headers: X-Custom-Header\\nHost: api.alice.com\\nAccept-Language: en-US\\nConnection: keep-alive\\nUser-Agent: Mozilla/5.0..\\n```\\n\\n**1）Access-Control-Request-Method**：必选\\n\\n  用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。\\n\\n**2）Access-Control-Request-Headers**：可选\\n\\n  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。\\n\\n预检请求的回应\\n\\n  服务器收到\\\"预检\\\"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\\n\\n  HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：\\n\\n**1）Access-Control-Allow-Methods**：必选\\n\\n  它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\\\"预检\\\"请求。\\n\\n**2）Access-Control-Allow-Headers**\\n\\n  如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\\\"预检\\\"中请求的字段。\\n\\n**3）Access-Control-Allow-Credentials**：可选\\n\\n  该字段与简单请求时的含义相同。\\n\\n**4）Access-Control-Max-Age**：可选\\n\\n  用来指定本次预检请求的有效期，单位为秒。\\n\\n##### CORS跨域示例\\n\\n**1）前端设置**：\\n\\n- 原生ajax：\\n\\n  ```js\\n  var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容\\n   \\n  // 前端设置是否带cookie\\n  xhr.withCredentials = true;\\n   \\n  xhr.open(\'post\', \'http://www.domain2.com:8080/login\', true);\\n  xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\\n  xhr.send(\'user=admin\');\\n   \\n  xhr.onreadystatechange = function() {\\n      if (xhr.readyState == 4 && xhr.status == 200) {\\n          alert(xhr.responseText);\\n      }\\n  };\\n  ```\\n\\n  **2）服务端设置**：\\n\\n  - nodejs代码\\n\\n  ```js\\n  var http = require(\'http\');\\n  var server = http.createServer();\\n  var qs = require(\'querystring\');\\n   \\n  server.on(\'request\', function(req, res) {\\n      var postData = \'\';\\n   \\n      // 数据块接收中\\n      req.addListener(\'data\', function(chunk) {\\n          postData += chunk;\\n      });\\n   \\n      // 数据接收完毕\\n      req.addListener(\'end\', function() {\\n          postData = qs.parse(postData);\\n   \\n          // 跨域后台设置\\n          res.writeHead(200, {\\n              \'Access-Control-Allow-Credentials\': \'true\',     // 后端允许发送Cookie\\n              \'Access-Control-Allow-Origin\': \'http://www.domain1.com\',    // 允许访问的域（协议+域名+端口）\\n              /* \\n               * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，\\n               * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问\\n               */\\n              \'Set-Cookie\': \'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly\'  // HttpOnly的作用是让js无法读取cookie\\n          });\\n   \\n          res.write(JSON.stringify(postData));\\n          res.end();\\n      });\\n  });\\n   \\n  server.listen(\'8080\');\\n  console.log(\'Server is running at port 8080...\');\\n  ```\\n\\n  #### 3、nginx代理跨域\\n\\n    nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。\\n\\n  1）nginx配置解决iconfont跨域\\n\\n    浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\\n\\n  ```\\n  location / {\\n    add_header Access-Control-Allow-Origin *;\\n  }\\n  ```\\n\\n  2）nginx反向代理接口跨域\\n\\n  > 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。\\n\\n  实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。\\n\\n  nginx具体配置：\\n\\n  ```\\n  #proxy服务器\\n  server {\\n      listen       81;\\n      server_name  www.domain1.com;\\n   \\n      location / {\\n          proxy_pass   http://www.domain2.com:8080;  #反向代理\\n          proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\\n          index  index.html index.htm;\\n   \\n          # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\\n          add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\\n          add_header Access-Control-Allow-Credentials true;\\n      }\\n  }\\n  ```\\n\\n## 3、nginx代理跨域\\n\\nnginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。\\n\\n1）nginx配置解决iconfont跨域\\n\\n  浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\\n\\n```\\nlocation / {\\n  add_header Access-Control-Allow-Origin *;\\n}\\n```\\n\\n2）nginx反向代理接口跨域\\n\\n> 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。\\n\\n实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。\\n\\nnginx具体配置：\\n\\n```\\n#proxy服务器\\nserver {\\n    listen       81;\\n    server_name  www.domain1.com;\\n \\n    location / {\\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\\n        index  index.html index.htm;\\n \\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\\n        add_header Access-Control-Allow-Credentials true;\\n    }\\n}\\n```\\n\\n## 4、nodejs中间件代理跨域\\n\\nnode中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。\\n\\n**1）非vue框架的跨域**\\n\\n  使用node + express + http-proxy-middleware搭建一个proxy服务器。\\n\\n- 前端代码：\\n\\n```js\\nvar xhr = new XMLHttpRequest();\\n \\n// 前端开关：浏览器是否读写cookie\\nxhr.withCredentials = true;\\n \\n// 访问http-proxy-middleware代理服务器\\nxhr.open(\'get\', \'http://www.domain1.com:3000/login?user=admin\', true);\\nxhr.send();\\n```\\n\\n- 中间件服务器代码：\\n\\n```js\\nvar express = require(\'express\');\\nvar proxy = require(\'http-proxy-middleware\');\\nvar app = express();\\n \\napp.use(\'/\', proxy({\\n    // 代理跨域目标接口\\n    target: \'http://www.domain2.com:8080\',\\n    changeOrigin: true,\\n \\n    // 修改响应头信息，实现跨域并允许带cookie\\n    onProxyRes: function(proxyRes, req, res) {\\n        res.header(\'Access-Control-Allow-Origin\', \'http://www.domain1.com\');\\n        res.header(\'Access-Control-Allow-Credentials\', \'true\');\\n    },\\n \\n    // 修改响应信息中的cookie域名\\n    cookieDomainRewrite: \'www.domain1.com\'  // 可以为false，表示不修改\\n}));\\n \\napp.listen(3000);\\nconsole.log(\'Proxy server is listen at port 3000...\');\\n \\n```\\n\\n**2）vue框架的跨域**\\n\\n  node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。\\n\\nwebpack.config.js部分配置：\\n\\n```js\\nmodule.exports = {\\n    entry: {},\\n    module: {},\\n    ...\\n    devServer: {\\n        historyApiFallback: true,\\n        proxy: [{\\n            context: \'/login\',\\n            target: \'http://www.domain2.com:8080\',  // 代理跨域目标接口\\n            changeOrigin: true,\\n            secure: false,  // 当代理某些https服务报错时用\\n            cookieDomainRewrite: \'www.domain1.com\'  // 可以为false，表示不修改\\n        }],\\n        noInfo: true\\n    }\\n}\\n```\\n\\n## 5、document.domain + iframe跨域\\n\\n  此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。\\n\\n1）父窗口：(http://www.domain.com/a.html)\\n\\n```html\\n<iframe id=\\\"iframe\\\" src=\\\"http://child.domain.com/b.html\\\"></iframe>\\n<script>\\n    document.domain = \'domain.com\';\\n    var user = \'admin\';\\n</script>\\n```\\n\\n2）子窗口：(http://child.domain.com/a.html)\\n\\n```html\\n<script>\\n    document.domain = \'domain.com\';\\n    // 获取父窗口中变量\\n    console.log(\'get js data from parent ---> \' + window.parent.user);\\n</script>\\n```\\n\\n## 6、window.name + iframe跨域\\n\\n  下面代码有3个html页面，a页面和b页面同域，c页面独立，第一步，使用a页面的iframe标签的src属性指向c页面地址，此时不做处理就是跨域请求，会报错；第二步，在a页面的iframe标签上面定义一个onload方法，他的作用是将src的地址改成b页面地址，a和b页面属于同源，可以进行通信。开始在a页面请求c的时候，c页面抛出一个**window.name**,这个方法在后来a页面访问b的时候仍然存在，不会消失！这样a页面就拿到了c页面数据，实现了跨域！\\n\\n1）a.html：(在本地服务的3000端口)\\n\\n```js\\n <iframe src=\\\"http://localhost:4000/c.html\\\" frameborder=\\\"0\\\" id=\\\"iframe\\\" onload=\\\"onload\\\"></iframe>\\n    <script>\\n        let first = true;//这个变量设置作用是修改src后页面从新渲染，会从新执行onload函数，防止死循环\\n        function onload(){\\n            if(first){\\n                let iframe = document.getElementById(\\\"iframe\\\")\\n                iframe.scr = \\\"http://localhost:3000/b.html\\\"\\n                first = false\\n            }else{\\n                console.log(iframe.contentWindow.name)//\\\"鸡腿太小\\\"\\n            }\\n        }\\n    </script>\\n```\\n\\n2）b.html：在本地服务的3000端口，不做任何处理)\\n\\n  中间代理页，与a.html同域，内容为空即可。\\n\\n3）c.html：(http://www.domain2.com/b.html)\\n\\n```html\\n<script>\\n    window.name = \'This is domain2 data!\';\\n</script>\\n```\\n\\n通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\\n\\n## 7、postMessage跨域\\n\\n  postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\\n\\n- 页面和其打开的新窗口的数据传递\\n- 多窗口之间消息传递\\n- 页面与嵌套的iframe消息传递\\n- 上面三个场景的跨域数据传递\\n\\n用法：postMessage(data,origin)方法接受两个参数：\\n\\n- **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\\n- **origin**： 协议+主机+端口号，也可以设置为\\\"*\\\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\\\"/\\\"\\n\\n\\n\\n```\\n  <iframe src=\\\"http://localhost:4000/b.html\\\" frameborder=\\\"0\\\" id=\\\"iframe\\\" onload=\\\"load()\\\"></iframe>\\n        //向b页面发送数据\\n        function load(){\\n            let iframe = document.getElementById(\\\"iframe\\\");\\n            iframe.contentWindow.postMessage(\\\"a页面数据\\\",\\\"http://localhost:4000\\\")\\n            // 接收b页面数据\\n            window.onmessage = function(e){\\n                console.log(e.data)\\n            }\\n        }\\n        \\n        //接收b页面数据\\n        window.onmessage = function(e){\\n            console.log(e.data)\\n        //像a页面发送数据\\n            e.source.postMessage(\\\"b页面数据\\\",e.origin)\\n        }\\n```\\n\\n\\n\\n## 8、WebSocket协议跨域\\n\\n  WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。\\n原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。\\n\\n1）前端代码：\\n\\n```html\\n<div>user input：<input type=\\\"text\\\"></div>\\n<script src=\\\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\\\"></script>\\n<script>\\nvar socket = io(\'http://www.domain2.com:8080\');\\n \\n// 连接成功处理\\nsocket.on(\'connect\', function() {\\n    // 监听服务端消息\\n    socket.on(\'message\', function(msg) {\\n        console.log(\'data from server: ---> \' + msg); \\n    });\\n \\n    // 监听服务端关闭\\n    socket.on(\'disconnect\', function() { \\n        console.log(\'Server socket has closed.\'); \\n    });\\n});\\n \\ndocument.getElementsByTagName(\'input\')[0].onblur = function() {\\n    socket.send(this.value);\\n};\\n</script>\\n```\\n\\n2）Nodejs socket后台：\\n\\n```js\\nvar http = require(\'http\');\\nvar socket = require(\'socket.io\');\\n \\n// 启http服务\\nvar server = http.createServer(function(req, res) {\\n    res.writeHead(200, {\\n        \'Content-type\': \'text/html\'\\n    });\\n    res.end();\\n});\\n \\nserver.listen(\'8080\');\\nconsole.log(\'Server is running at port 8080...\');\\n \\n// 监听socket连接\\nsocket.listen(server).on(\'connection\', function(client) {\\n    // 接收信息\\n    client.on(\'message\', function(msg) {\\n        client.send(\'hello：\' + msg);\\n        console.log(\'data from client: ---> \' + msg);\\n    });\\n \\n    // 断开处理\\n    client.on(\'disconnect\', function() {\\n        console.log(\'Client socket has closed.\'); \\n    });\\n});\\n```\\n\\n## 小结\\n\\n以上就是8种常见的跨域解决方案，jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。document.domain+iframe适合主域名相同，子域名不同的跨域请求。postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。\\n\\n', '<h1><a id=\\\"_0\\\"></a>前端跨域的几种实现方式</h1>\\n<h2><a id=\\\"_1\\\"></a>什么是跨域？</h2>\\n<p>在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能<strong>同源</strong>使用的限制。</p>\\n<h2><a id=\\\"_5\\\"></a>什么是同源策略？</h2>\\n<p><strong>同源策略</strong>是一种约定，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。</p>\\n<p>同源策略限制以下几种行为：</p>\\n<ul>\\n<li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>\\n<li>当前域下的 js 脚本不能够操作访问其他域下的 DOM。</li>\\n<li>当前域下 ajax 无法发送跨域请求。</li>\\n</ul>\\n<p>script、image、iframe的src都不受同源策略的影响</p>\\n<h2><a id=\\\"1JSONP_18\\\"></a>1、JSONP跨域</h2>\\n<p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>\\n<p>jsonp的缺点：只能发送get一种请求。</p>\\n<p>1）原生JS实现：</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"> &lt;script&gt;\\n    <span class=\\\"hljs-keyword\\\">var</span> script = <span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-title function_\\\">createElement</span>(<span class=\\\"hljs-string\\\">&#x27;script&#x27;</span>);\\n    script.<span class=\\\"hljs-property\\\">type</span> = <span class=\\\"hljs-string\\\">&#x27;text/javascript&#x27;</span>;\\n \\n    <span class=\\\"hljs-comment\\\">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span>\\n    script.<span class=\\\"hljs-property\\\">src</span> = <span class=\\\"hljs-string\\\">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;\\n    <span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-property\\\">head</span>.<span class=\\\"hljs-title function_\\\">appendChild</span>(script);\\n \\n    <span class=\\\"hljs-comment\\\">// 回调执行函数</span>\\n    <span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">handleCallback</span>(<span class=\\\"hljs-params\\\">res</span>) {\\n        <span class=\\\"hljs-title function_\\\">alert</span>(<span class=\\\"hljs-title class_\\\">JSON</span>.<span class=\\\"hljs-title function_\\\">stringify</span>(res));\\n    }\\n &lt;/script&gt;\\n \\n 服务端返回如下（返回时即执行全局函数）：\\n <span class=\\\"hljs-title function_\\\">handleCallback</span>({<span class=\\\"hljs-string\\\">&quot;success&quot;</span>: <span class=\\\"hljs-literal\\\">true</span>, <span class=\\\"hljs-string\\\">&quot;user&quot;</span>: <span class=\\\"hljs-string\\\">&quot;admin&quot;</span>})\\n\\n</code></div></pre>\\n<p>2.Vue axios实现：</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">$http</span> = axios;\\n<span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">$http</span>.<span class=\\\"hljs-title function_\\\">jsonp</span>(<span class=\\\"hljs-string\\\">&#x27;http://www.domain2.com:8080/login&#x27;</span>, {\\n    <span class=\\\"hljs-attr\\\">params</span>: {},\\n    <span class=\\\"hljs-attr\\\">jsonp</span>: <span class=\\\"hljs-string\\\">&#x27;handleCallback&#x27;</span>\\n}).<span class=\\\"hljs-title function_\\\">then</span>(<span class=\\\"hljs-function\\\">(<span class=\\\"hljs-params\\\">res</span>) =&gt;</span> {\\n    <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(res); \\n})\\n</code></div></pre>\\n<p>后端代码 node.js</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">var</span> querystring = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;querystring&#x27;</span>);\\n<span class=\\\"hljs-keyword\\\">var</span> http = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;http&#x27;</span>);\\n<span class=\\\"hljs-keyword\\\">var</span> server = http.<span class=\\\"hljs-title function_\\\">createServer</span>();\\n \\nserver.<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;request&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">req, res</span>) {\\n    <span class=\\\"hljs-keyword\\\">var</span> params = querystring.<span class=\\\"hljs-title function_\\\">parse</span>(req.<span class=\\\"hljs-property\\\">url</span>.<span class=\\\"hljs-title function_\\\">split</span>(<span class=\\\"hljs-string\\\">&#x27;?&#x27;</span>)[<span class=\\\"hljs-number\\\">1</span>]);\\n    <span class=\\\"hljs-keyword\\\">var</span> fn = params.<span class=\\\"hljs-property\\\">callback</span>;\\n \\n    <span class=\\\"hljs-comment\\\">// jsonp返回设置</span>\\n    res.<span class=\\\"hljs-title function_\\\">writeHead</span>(<span class=\\\"hljs-number\\\">200</span>, { <span class=\\\"hljs-string\\\">&#x27;Content-Type&#x27;</span>: <span class=\\\"hljs-string\\\">&#x27;text/javascript&#x27;</span> });\\n    res.<span class=\\\"hljs-title function_\\\">write</span>(fn + <span class=\\\"hljs-string\\\">&#x27;(&#x27;</span> + <span class=\\\"hljs-title class_\\\">JSON</span>.<span class=\\\"hljs-title function_\\\">stringify</span>(params) + <span class=\\\"hljs-string\\\">&#x27;)&#x27;</span>);\\n \\n    res.<span class=\\\"hljs-title function_\\\">end</span>();\\n});\\n \\nserver.<span class=\\\"hljs-title function_\\\">listen</span>(<span class=\\\"hljs-string\\\">&#x27;8080&#x27;</span>);\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;Server is running at port 8080...&#x27;</span>);\\n</code></div></pre>\\n<h2><a id=\\\"2CORS_80\\\"></a>2、跨域资源共享（CORS）</h2>\\n<p><strong>CORS</strong>是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。<br />\\n它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br />\\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>\\n<p>浏览器将CORS跨域请求分为简单请求和非简单请求。</p>\\n<p>只要同时满足一下两个条件，就属于简单请求</p>\\n<p>(1)使用下列方法之一：</p>\\n<ul>\\n<li>head</li>\\n<li>get</li>\\n<li>post</li>\\n</ul>\\n<p>(2)请求的Heder是</p>\\n<ul>\\n<li>Accept</li>\\n<li>Accept-Language</li>\\n<li>Content-Language</li>\\n<li>Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\\n</ul>\\n<p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p>\\n<h6><a id=\\\"_105\\\"></a>简单请求</h6>\\n<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>\\n<pre><code class=\\\"lang-\\\">GET /cors HTTP/1.1\\nOrigin: http://api.bob.com\\nHost: api.alice.com\\nAccept-Language: en-US\\nConnection: keep-alive\\nUser-Agent: Mozilla/5.0...\\n</code></pre>\\n<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>\\n<p>CORS请求设置的响应头字段，都以 Access-Control-开头:</p>\\n<p><strong>1）Access-Control-Allow-Origin</strong>：必选</p>\\n<p>它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>\\n<p><strong>2）Access-Control-Allow-Credentials</strong>：可选</p>\\n<p>它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>\\n<p><strong>3）Access-Control-Expose-Headers</strong>：可选</p>\\n<p>CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>\\n<h6><a id=\\\"_134\\\"></a>非简单请求</h6>\\n<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>\\n<p>预检请求</p>\\n<p>预检&quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>\\n<pre><code class=\\\"lang-\\\">OPTIONS /cors HTTP/1.1\\nOrigin: http://api.bob.com\\nAccess-Control-Request-Method: PUT\\nAccess-Control-Request-Headers: X-Custom-Header\\nHost: api.alice.com\\nAccept-Language: en-US\\nConnection: keep-alive\\nUser-Agent: Mozilla/5.0..\\n</code></pre>\\n<p><strong>1）Access-Control-Request-Method</strong>：必选</p>\\n<p>用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p>\\n<p><strong>2）Access-Control-Request-Headers</strong>：可选</p>\\n<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p>\\n<p>预检请求的回应</p>\\n<p>服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>\\n<p>HTTP回应中，除了关键的是Access-Control-Allow-Origin字段，其他CORS相关字段如下：</p>\\n<p><strong>1）Access-Control-Allow-Methods</strong>：必选</p>\\n<p>它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>\\n<p><strong>2）Access-Control-Allow-Headers</strong></p>\\n<p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</p>\\n<p><strong>3）Access-Control-Allow-Credentials</strong>：可选</p>\\n<p>该字段与简单请求时的含义相同。</p>\\n<p><strong>4）Access-Control-Max-Age</strong>：可选</p>\\n<p>用来指定本次预检请求的有效期，单位为秒。</p>\\n<h5><a id=\\\"CORS_183\\\"></a>CORS跨域示例</h5>\\n<p><strong>1）前端设置</strong>：</p>\\n<ul>\\n<li>\\n<p>原生ajax：</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">var</span> xhr = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">XMLHttpRequest</span>(); <span class=\\\"hljs-comment\\\">// IE8/9需用window.XDomainRequest兼容</span>\\n \\n<span class=\\\"hljs-comment\\\">// 前端设置是否带cookie</span>\\nxhr.<span class=\\\"hljs-property\\\">withCredentials</span> = <span class=\\\"hljs-literal\\\">true</span>;\\n \\nxhr.<span class=\\\"hljs-title function_\\\">open</span>(<span class=\\\"hljs-string\\\">&#x27;post&#x27;</span>, <span class=\\\"hljs-string\\\">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class=\\\"hljs-literal\\\">true</span>);\\nxhr.<span class=\\\"hljs-title function_\\\">setRequestHeader</span>(<span class=\\\"hljs-string\\\">&#x27;Content-Type&#x27;</span>, <span class=\\\"hljs-string\\\">&#x27;application/x-www-form-urlencoded&#x27;</span>);\\nxhr.<span class=\\\"hljs-title function_\\\">send</span>(<span class=\\\"hljs-string\\\">&#x27;user=admin&#x27;</span>);\\n \\nxhr.<span class=\\\"hljs-property\\\">onreadystatechange</span> = <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) {\\n    <span class=\\\"hljs-keyword\\\">if</span> (xhr.<span class=\\\"hljs-property\\\">readyState</span> == <span class=\\\"hljs-number\\\">4</span> &amp;&amp; xhr.<span class=\\\"hljs-property\\\">status</span> == <span class=\\\"hljs-number\\\">200</span>) {\\n        <span class=\\\"hljs-title function_\\\">alert</span>(xhr.<span class=\\\"hljs-property\\\">responseText</span>);\\n    }\\n};\\n</code></div></pre>\\n<p><strong>2）服务端设置</strong>：</p>\\n<ul>\\n<li>nodejs代码</li>\\n</ul>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">var</span> http = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;http&#x27;</span>);\\n<span class=\\\"hljs-keyword\\\">var</span> server = http.<span class=\\\"hljs-title function_\\\">createServer</span>();\\n<span class=\\\"hljs-keyword\\\">var</span> qs = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;querystring&#x27;</span>);\\n \\nserver.<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;request&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">req, res</span>) {\\n    <span class=\\\"hljs-keyword\\\">var</span> postData = <span class=\\\"hljs-string\\\">&#x27;&#x27;</span>;\\n \\n    <span class=\\\"hljs-comment\\\">// 数据块接收中</span>\\n    req.<span class=\\\"hljs-title function_\\\">addListener</span>(<span class=\\\"hljs-string\\\">&#x27;data&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">chunk</span>) {\\n        postData += chunk;\\n    });\\n \\n    <span class=\\\"hljs-comment\\\">// 数据接收完毕</span>\\n    req.<span class=\\\"hljs-title function_\\\">addListener</span>(<span class=\\\"hljs-string\\\">&#x27;end&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) {\\n        postData = qs.<span class=\\\"hljs-title function_\\\">parse</span>(postData);\\n \\n        <span class=\\\"hljs-comment\\\">// 跨域后台设置</span>\\n        res.<span class=\\\"hljs-title function_\\\">writeHead</span>(<span class=\\\"hljs-number\\\">200</span>, {\\n            <span class=\\\"hljs-string\\\">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class=\\\"hljs-string\\\">&#x27;true&#x27;</span>,     <span class=\\\"hljs-comment\\\">// 后端允许发送Cookie</span>\\n            <span class=\\\"hljs-string\\\">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class=\\\"hljs-string\\\">&#x27;http://www.domain1.com&#x27;</span>,    <span class=\\\"hljs-comment\\\">// 允许访问的域（协议+域名+端口）</span>\\n            <span class=\\\"hljs-comment\\\">/* \\n             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，\\n             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问\\n             */</span>\\n            <span class=\\\"hljs-string\\\">&#x27;Set-Cookie&#x27;</span>: <span class=\\\"hljs-string\\\">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>  <span class=\\\"hljs-comment\\\">// HttpOnly的作用是让js无法读取cookie</span>\\n        });\\n \\n        res.<span class=\\\"hljs-title function_\\\">write</span>(<span class=\\\"hljs-title class_\\\">JSON</span>.<span class=\\\"hljs-title function_\\\">stringify</span>(postData));\\n        res.<span class=\\\"hljs-title function_\\\">end</span>();\\n    });\\n});\\n \\nserver.<span class=\\\"hljs-title function_\\\">listen</span>(<span class=\\\"hljs-string\\\">&#x27;8080&#x27;</span>);\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;Server is running at port 8080...&#x27;</span>);\\n</code></div></pre>\\n<h4><a id=\\\"3nginx_247\\\"></a>3、nginx代理跨域</h4>\\n<p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>\\n<p>1）nginx配置解决iconfont跨域</p>\\n<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>\\n<pre><code class=\\\"lang-\\\">location / {\\n  add_header Access-Control-Allow-Origin *;\\n}\\n</code></pre>\\n<p>2）nginx反向代理接口跨域</p>\\n<blockquote>\\n<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>\\n</blockquote>\\n<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>\\n<p>nginx具体配置：</p>\\n<pre><code class=\\\"lang-\\\">#proxy服务器\\nserver {\\n    listen       81;\\n    server_name  www.domain1.com;\\n \\n    location / {\\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\\n        index  index.html index.htm;\\n \\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\\n        add_header Access-Control-Allow-Credentials true;\\n    }\\n}\\n</code></pre>\\n</li>\\n</ul>\\n<h2><a id=\\\"3nginx_287\\\"></a>3、nginx代理跨域</h2>\\n<p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>\\n<p>1）nginx配置解决iconfont跨域</p>\\n<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>\\n<pre><code class=\\\"lang-\\\">location / {\\n  add_header Access-Control-Allow-Origin *;\\n}\\n</code></pre>\\n<p>2）nginx反向代理接口跨域</p>\\n<blockquote>\\n<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>\\n</blockquote>\\n<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>\\n<p>nginx具体配置：</p>\\n<pre><code class=\\\"lang-\\\">#proxy服务器\\nserver {\\n    listen       81;\\n    server_name  www.domain1.com;\\n \\n    location / {\\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\\n        index  index.html index.htm;\\n \\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\\n        add_header Access-Control-Allow-Credentials true;\\n    }\\n}\\n</code></pre>\\n<h2><a id=\\\"4nodejs_327\\\"></a>4、nodejs中间件代理跨域</h2>\\n<p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>\\n<p><strong>1）非vue框架的跨域</strong></p>\\n<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>\\n<ul>\\n<li>前端代码：</li>\\n</ul>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">var</span> xhr = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">XMLHttpRequest</span>();\\n \\n<span class=\\\"hljs-comment\\\">// 前端开关：浏览器是否读写cookie</span>\\nxhr.<span class=\\\"hljs-property\\\">withCredentials</span> = <span class=\\\"hljs-literal\\\">true</span>;\\n \\n<span class=\\\"hljs-comment\\\">// 访问http-proxy-middleware代理服务器</span>\\nxhr.<span class=\\\"hljs-title function_\\\">open</span>(<span class=\\\"hljs-string\\\">&#x27;get&#x27;</span>, <span class=\\\"hljs-string\\\">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class=\\\"hljs-literal\\\">true</span>);\\nxhr.<span class=\\\"hljs-title function_\\\">send</span>();\\n</code></div></pre>\\n<ul>\\n<li>中间件服务器代码：</li>\\n</ul>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">var</span> express = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;express&#x27;</span>);\\n<span class=\\\"hljs-keyword\\\">var</span> proxy = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;http-proxy-middleware&#x27;</span>);\\n<span class=\\\"hljs-keyword\\\">var</span> app = <span class=\\\"hljs-title function_\\\">express</span>();\\n \\napp.<span class=\\\"hljs-title function_\\\">use</span>(<span class=\\\"hljs-string\\\">&#x27;/&#x27;</span>, <span class=\\\"hljs-title function_\\\">proxy</span>({\\n    <span class=\\\"hljs-comment\\\">// 代理跨域目标接口</span>\\n    <span class=\\\"hljs-attr\\\">target</span>: <span class=\\\"hljs-string\\\">&#x27;http://www.domain2.com:8080&#x27;</span>,\\n    <span class=\\\"hljs-attr\\\">changeOrigin</span>: <span class=\\\"hljs-literal\\\">true</span>,\\n \\n    <span class=\\\"hljs-comment\\\">// 修改响应头信息，实现跨域并允许带cookie</span>\\n    <span class=\\\"hljs-attr\\\">onProxyRes</span>: <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">proxyRes, req, res</span>) {\\n        res.<span class=\\\"hljs-title function_\\\">header</span>(<span class=\\\"hljs-string\\\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\\\"hljs-string\\\">&#x27;http://www.domain1.com&#x27;</span>);\\n        res.<span class=\\\"hljs-title function_\\\">header</span>(<span class=\\\"hljs-string\\\">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class=\\\"hljs-string\\\">&#x27;true&#x27;</span>);\\n    },\\n \\n    <span class=\\\"hljs-comment\\\">// 修改响应信息中的cookie域名</span>\\n    <span class=\\\"hljs-attr\\\">cookieDomainRewrite</span>: <span class=\\\"hljs-string\\\">&#x27;www.domain1.com&#x27;</span>  <span class=\\\"hljs-comment\\\">// 可以为false，表示不修改</span>\\n}));\\n \\napp.<span class=\\\"hljs-title function_\\\">listen</span>(<span class=\\\"hljs-number\\\">3000</span>);\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;Proxy server is listen at port 3000...&#x27;</span>);\\n \\n</code></div></pre>\\n<p><strong>2）vue框架的跨域</strong></p>\\n<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>\\n<p>webpack.config.js部分配置：</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-variable language_\\\">module</span>.<span class=\\\"hljs-property\\\">exports</span> = {\\n    <span class=\\\"hljs-attr\\\">entry</span>: {},\\n    <span class=\\\"hljs-attr\\\">module</span>: {},\\n    ...\\n    <span class=\\\"hljs-attr\\\">devServer</span>: {\\n        <span class=\\\"hljs-attr\\\">historyApiFallback</span>: <span class=\\\"hljs-literal\\\">true</span>,\\n        <span class=\\\"hljs-attr\\\">proxy</span>: [{\\n            <span class=\\\"hljs-attr\\\">context</span>: <span class=\\\"hljs-string\\\">&#x27;/login&#x27;</span>,\\n            <span class=\\\"hljs-attr\\\">target</span>: <span class=\\\"hljs-string\\\">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class=\\\"hljs-comment\\\">// 代理跨域目标接口</span>\\n            <span class=\\\"hljs-attr\\\">changeOrigin</span>: <span class=\\\"hljs-literal\\\">true</span>,\\n            <span class=\\\"hljs-attr\\\">secure</span>: <span class=\\\"hljs-literal\\\">false</span>,  <span class=\\\"hljs-comment\\\">// 当代理某些https服务报错时用</span>\\n            <span class=\\\"hljs-attr\\\">cookieDomainRewrite</span>: <span class=\\\"hljs-string\\\">&#x27;www.domain1.com&#x27;</span>  <span class=\\\"hljs-comment\\\">// 可以为false，表示不修改</span>\\n        }],\\n        <span class=\\\"hljs-attr\\\">noInfo</span>: <span class=\\\"hljs-literal\\\">true</span>\\n    }\\n}\\n</code></div></pre>\\n<h2><a id=\\\"5documentdomain__iframe_400\\\"></a>5、document.domain + iframe跨域</h2>\\n<p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>\\n<p>1）父窗口：(http://www.domain.com/a.html)</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-html\\\"><span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">iframe</span> <span class=\\\"hljs-attr\\\">id</span>=<span class=\\\"hljs-string\\\">&quot;iframe&quot;</span> <span class=\\\"hljs-attr\\\">src</span>=<span class=\\\"hljs-string\\\">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">iframe</span>&gt;</span>\\n<span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">script</span>&gt;</span><span class=\\\"language-javascript\\\">\\n    <span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-property\\\">domain</span> = <span class=\\\"hljs-string\\\">&#x27;domain.com&#x27;</span>;\\n    <span class=\\\"hljs-keyword\\\">var</span> user = <span class=\\\"hljs-string\\\">&#x27;admin&#x27;</span>;\\n</span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">script</span>&gt;</span>\\n</code></div></pre>\\n<p>2）子窗口：(http://child.domain.com/a.html)</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-html\\\"><span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">script</span>&gt;</span><span class=\\\"language-javascript\\\">\\n    <span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-property\\\">domain</span> = <span class=\\\"hljs-string\\\">&#x27;domain.com&#x27;</span>;\\n    <span class=\\\"hljs-comment\\\">// 获取父窗口中变量</span>\\n    <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class=\\\"hljs-variable language_\\\">window</span>.<span class=\\\"hljs-property\\\">parent</span>.<span class=\\\"hljs-property\\\">user</span>);\\n</span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">script</span>&gt;</span>\\n</code></div></pre>\\n<h2><a id=\\\"6windowname__iframe_424\\\"></a>6、window.name + iframe跨域</h2>\\n<p>下面代码有3个html页面，a页面和b页面同域，c页面独立，第一步，使用a页面的iframe标签的src属性指向c页面地址，此时不做处理就是跨域请求，会报错；第二步，在a页面的iframe标签上面定义一个onload方法，他的作用是将src的地址改成b页面地址，a和b页面属于同源，可以进行通信。开始在a页面请求c的时候，c页面抛出一个<strong>window.name</strong>,这个方法在后来a页面访问b的时候仍然存在，不会消失！这样a页面就拿到了c页面数据，实现了跨域！</p>\\n<p>1）a.html：(在本地服务的3000端口)</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"> &lt;iframe src=<span class=\\\"hljs-string\\\">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class=\\\"hljs-string\\\">&quot;0&quot;</span> id=<span class=\\\"hljs-string\\\">&quot;iframe&quot;</span> onload=<span class=\\\"hljs-string\\\">&quot;onload&quot;</span>&gt;&lt;/iframe&gt;\\n    <span class=\\\"language-xml\\\"><span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">script</span>&gt;</span><span class=\\\"language-javascript\\\">\\n        <span class=\\\"hljs-keyword\\\">let</span> first = <span class=\\\"hljs-literal\\\">true</span>;<span class=\\\"hljs-comment\\\">//这个变量设置作用是修改src后页面从新渲染，会从新执行onload函数，防止死循环</span>\\n        <span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">onload</span>(<span class=\\\"hljs-params\\\"></span>){\\n            <span class=\\\"hljs-keyword\\\">if</span>(first){\\n                <span class=\\\"hljs-keyword\\\">let</span> iframe = <span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-title function_\\\">getElementById</span>(<span class=\\\"hljs-string\\\">&quot;iframe&quot;</span>)\\n                iframe.<span class=\\\"hljs-property\\\">scr</span> = <span class=\\\"hljs-string\\\">&quot;http://localhost:3000/b.html&quot;</span>\\n                first = <span class=\\\"hljs-literal\\\">false</span>\\n            }<span class=\\\"hljs-keyword\\\">else</span>{\\n                <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(iframe.<span class=\\\"hljs-property\\\">contentWindow</span>.<span class=\\\"hljs-property\\\">name</span>)<span class=\\\"hljs-comment\\\">//&quot;鸡腿太小&quot;</span>\\n            }\\n        }\\n    </span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">script</span>&gt;</span></span>\\n</code></div></pre>\\n<p>2）b.html：在本地服务的3000端口，不做任何处理)</p>\\n<p>中间代理页，与a.html同域，内容为空即可。</p>\\n<p>3）c.html：(http://www.domain2.com/b.html)</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-html\\\"><span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">script</span>&gt;</span><span class=\\\"language-javascript\\\">\\n    <span class=\\\"hljs-variable language_\\\">window</span>.<span class=\\\"hljs-property\\\">name</span> = <span class=\\\"hljs-string\\\">&#x27;This is domain2 data!&#x27;</span>;\\n</span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">script</span>&gt;</span>\\n</code></div></pre>\\n<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\\n<h2><a id=\\\"7postMessage_460\\\"></a>7、postMessage跨域</h2>\\n<p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\\n<ul>\\n<li>页面和其打开的新窗口的数据传递</li>\\n<li>多窗口之间消息传递</li>\\n<li>页面与嵌套的iframe消息传递</li>\\n<li>上面三个场景的跨域数据传递</li>\\n</ul>\\n<p>用法：postMessage(data,origin)方法接受两个参数：</p>\\n<ul>\\n<li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>\\n<li><strong>origin</strong>： 协议+主机+端口号，也可以设置为&quot;*&quot;，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为&quot;/&quot;</li>\\n</ul>\\n<pre><code class=\\\"lang-\\\">  &lt;iframe src=&quot;http://localhost:4000/b.html&quot; frameborder=&quot;0&quot; id=&quot;iframe&quot; onload=&quot;load()&quot;&gt;&lt;/iframe&gt;\\n        //向b页面发送数据\\n        function load(){\\n            let iframe = document.getElementById(&quot;iframe&quot;);\\n            iframe.contentWindow.postMessage(&quot;a页面数据&quot;,&quot;http://localhost:4000&quot;)\\n            // 接收b页面数据\\n            window.onmessage = function(e){\\n                console.log(e.data)\\n            }\\n        }\\n        \\n        //接收b页面数据\\n        window.onmessage = function(e){\\n            console.log(e.data)\\n        //像a页面发送数据\\n            e.source.postMessage(&quot;b页面数据&quot;,e.origin)\\n        }\\n</code></pre>\\n<h2><a id=\\\"8WebSocket_498\\\"></a>8、WebSocket协议跨域</h2>\\n<p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br />\\n原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>\\n<p>1）前端代码：</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-html\\\"><span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">div</span>&gt;</span>user input：<span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">input</span> <span class=\\\"hljs-attr\\\">type</span>=<span class=\\\"hljs-string\\\">&quot;text&quot;</span>&gt;</span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">div</span>&gt;</span>\\n<span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">script</span> <span class=\\\"hljs-attr\\\">src</span>=<span class=\\\"hljs-string\\\">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">script</span>&gt;</span>\\n<span class=\\\"hljs-tag\\\">&lt;<span class=\\\"hljs-name\\\">script</span>&gt;</span><span class=\\\"language-javascript\\\">\\n<span class=\\\"hljs-keyword\\\">var</span> socket = <span class=\\\"hljs-title function_\\\">io</span>(<span class=\\\"hljs-string\\\">&#x27;http://www.domain2.com:8080&#x27;</span>);\\n \\n<span class=\\\"hljs-comment\\\">// 连接成功处理</span>\\nsocket.<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;connect&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) {\\n    <span class=\\\"hljs-comment\\\">// 监听服务端消息</span>\\n    socket.<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;message&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">msg</span>) {\\n        <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;data from server: ---&gt; &#x27;</span> + msg); \\n    });\\n \\n    <span class=\\\"hljs-comment\\\">// 监听服务端关闭</span>\\n    socket.<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;disconnect&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) { \\n        <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;Server socket has closed.&#x27;</span>); \\n    });\\n});\\n \\n<span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-title function_\\\">getElementsByTagName</span>(<span class=\\\"hljs-string\\\">&#x27;input&#x27;</span>)[<span class=\\\"hljs-number\\\">0</span>].<span class=\\\"hljs-property\\\">onblur</span> = <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) {\\n    socket.<span class=\\\"hljs-title function_\\\">send</span>(<span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">value</span>);\\n};\\n</span><span class=\\\"hljs-tag\\\">&lt;/<span class=\\\"hljs-name\\\">script</span>&gt;</span>\\n</code></div></pre>\\n<p>2）Nodejs socket后台：</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">var</span> http = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;http&#x27;</span>);\\n<span class=\\\"hljs-keyword\\\">var</span> socket = <span class=\\\"hljs-built_in\\\">require</span>(<span class=\\\"hljs-string\\\">&#x27;socket.io&#x27;</span>);\\n \\n<span class=\\\"hljs-comment\\\">// 启http服务</span>\\n<span class=\\\"hljs-keyword\\\">var</span> server = http.<span class=\\\"hljs-title function_\\\">createServer</span>(<span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">req, res</span>) {\\n    res.<span class=\\\"hljs-title function_\\\">writeHead</span>(<span class=\\\"hljs-number\\\">200</span>, {\\n        <span class=\\\"hljs-string\\\">&#x27;Content-type&#x27;</span>: <span class=\\\"hljs-string\\\">&#x27;text/html&#x27;</span>\\n    });\\n    res.<span class=\\\"hljs-title function_\\\">end</span>();\\n});\\n \\nserver.<span class=\\\"hljs-title function_\\\">listen</span>(<span class=\\\"hljs-string\\\">&#x27;8080&#x27;</span>);\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;Server is running at port 8080...&#x27;</span>);\\n \\n<span class=\\\"hljs-comment\\\">// 监听socket连接</span>\\nsocket.<span class=\\\"hljs-title function_\\\">listen</span>(server).<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;connection&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">client</span>) {\\n    <span class=\\\"hljs-comment\\\">// 接收信息</span>\\n    client.<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;message&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\">msg</span>) {\\n        client.<span class=\\\"hljs-title function_\\\">send</span>(<span class=\\\"hljs-string\\\">&#x27;hello：&#x27;</span> + msg);\\n        <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;data from client: ---&gt; &#x27;</span> + msg);\\n    });\\n \\n    <span class=\\\"hljs-comment\\\">// 断开处理</span>\\n    client.<span class=\\\"hljs-title function_\\\">on</span>(<span class=\\\"hljs-string\\\">&#x27;disconnect&#x27;</span>, <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>) {\\n        <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(<span class=\\\"hljs-string\\\">&#x27;Client socket has closed.&#x27;</span>); \\n    });\\n});\\n</code></div></pre>\\n<h2><a id=\\\"_562\\\"></a>小结</h2>\\n<p>以上就是8种常见的跨域解决方案，jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，这适合前后端分离的前端项目调后端接口。document.domain+iframe适合主域名相同，子域名不同的跨域请求。postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。</p>\\n');
INSERT INTO `bb_notes` VALUES ('3', '前端如何实现单点登录', '单点登录 （Single Sign On），简称为 `SSO`，是指在同一账号平台下的多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统，实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。', 'JavaScript', 'https://img0.baidu.com/it/u=9697420,4044494942&fm=253&fmt=auto&app=138&f=JPEG?w=800&h=500', '1122', '0', '2022-12-03 12:33:23', '2022-12-03 12:33:23', '# 前端如何实现单点登录\\n**单点登录** （Single Sign On），简称为 `SSO`，是指在同一账号平台下的多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统\\n\\n举个例子，`系统A` 和 `系统B` 都属于某公司下的两个不同的应用系统，当用户登录 `系统A` 后，再打开 `系统B` ，系统便会自动帮用户登录 `系统B` ，这种现象就属于单点登录\\n\\n实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。\\n\\n## 实现方式一：父域 Cookie\\n\\nCookie 的作用域由 domain 属性和 path 属性共同决定。\\n\\n利用 Cookie 的这个特点，不难想到，将 Session ID（或 Token）保存到父域中不就行了。没错，我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，这样所有的子域应用就都可以访问到这个 Cookie 了。\\n\\n不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。\\n\\n总结：此种实现方式比较简单，但不支持跨主域名。\\n\\n\\n## 实现方式二：LocalStorage 跨域\\n\\n实现方案\\n\\n  前端拿到 `Token` 后，不仅要将它写入当前域下的 `localStorage` 中，还要通过 `iframe + postMessage()` 的方式将它写入多个信任的其他域下的 `localStorage` 中，从而实现登录状态的共享\\n\\n  将 `Token` 写入多个域名下的 `localStorage` 中\\n\\n  ```js\\n  const iframe = document.createElement(\'iframe\')\\n  iframe.src = \'http://www.app.com/static/bridge.html\'\\n  iframe.addEventListener(\'load\', event => {\\n    iframe.contentWindow.postMessage(token, \'http://www.app.com/static/bridge.html\')\\n  })\\n  document.body.append(iframe)\\n  ```\\n\\n  在 `iframe` 加载的页面中绑定事件监听器，用来接收 `Token` 数据\\n\\n  ```js\\n  window.addEventListener(\'message\', ({ data, origin, srouce }) => {\\n    localStorage.setItem(\'AUTH-TOKEN\', data)\\n  })\\n  ```\\n\\n  在各个应用系统请求的 `Header` 中携带 `Token` 令牌\\n\\n  ```js\\n  config.headers.common[\'Authorization\'] = \'Bearer \' + token\\n  ```\\n\\n### \\n', '<h1><a id=\\\"_0\\\"></a>前端如何实现单点登录</h1>\\n<p><strong>单点登录</strong> （Single Sign On），简称为 <code>SSO</code>，是指在同一账号平台下的多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p>\\n<p>举个例子，<code>系统A</code> 和 <code>系统B</code> 都属于某公司下的两个不同的应用系统，当用户登录 <code>系统A</code> 后，再打开 <code>系统B</code> ，系统便会自动帮用户登录 <code>系统B</code> ，这种现象就属于单点登录</p>\\n<p>实现单点登录的关键在于，如何让 Session ID（或 Token）在多个域中共享。</p>\\n<h2><a id=\\\"_Cookie_7\\\"></a>实现方式一：父域 Cookie</h2>\\n<p>Cookie 的作用域由 domain 属性和 path 属性共同决定。</p>\\n<p>利用 Cookie 的这个特点，不难想到，将 Session ID（或 Token）保存到父域中不就行了。没错，我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，这样所有的子域应用就都可以访问到这个 Cookie 了。</p>\\n<p>不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录。</p>\\n<p>总结：此种实现方式比较简单，但不支持跨主域名。</p>\\n<h2><a id=\\\"LocalStorage__18\\\"></a>实现方式二：LocalStorage 跨域</h2>\\n<p>实现方案</p>\\n<p>前端拿到 <code>Token</code> 后，不仅要将它写入当前域下的 <code>localStorage</code> 中，还要通过 <code>iframe + postMessage()</code> 的方式将它写入多个信任的其他域下的 <code>localStorage</code> 中，从而实现登录状态的共享</p>\\n<p>将 <code>Token</code> 写入多个域名下的 <code>localStorage</code> 中</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">const</span> iframe = <span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-title function_\\\">createElement</span>(<span class=\\\"hljs-string\\\">&#x27;iframe&#x27;</span>)\\niframe.<span class=\\\"hljs-property\\\">src</span> = <span class=\\\"hljs-string\\\">&#x27;http://www.app.com/static/bridge.html&#x27;</span>\\niframe.<span class=\\\"hljs-title function_\\\">addEventListener</span>(<span class=\\\"hljs-string\\\">&#x27;load&#x27;</span>, <span class=\\\"hljs-function\\\"><span class=\\\"hljs-params\\\">event</span> =&gt;</span> {\\n  iframe.<span class=\\\"hljs-property\\\">contentWindow</span>.<span class=\\\"hljs-title function_\\\">postMessage</span>(token, <span class=\\\"hljs-string\\\">&#x27;http://www.app.com/static/bridge.html&#x27;</span>)\\n})\\n<span class=\\\"hljs-variable language_\\\">document</span>.<span class=\\\"hljs-property\\\">body</span>.<span class=\\\"hljs-title function_\\\">append</span>(iframe)\\n</code></div></pre>\\n<p>在 <code>iframe</code> 加载的页面中绑定事件监听器，用来接收 <code>Token</code> 数据</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-variable language_\\\">window</span>.<span class=\\\"hljs-title function_\\\">addEventListener</span>(<span class=\\\"hljs-string\\\">&#x27;message&#x27;</span>, <span class=\\\"hljs-function\\\">(<span class=\\\"hljs-params\\\">{ data, origin, srouce }</span>) =&gt;</span> {\\n  <span class=\\\"hljs-variable language_\\\">localStorage</span>.<span class=\\\"hljs-title function_\\\">setItem</span>(<span class=\\\"hljs-string\\\">&#x27;AUTH-TOKEN&#x27;</span>, data)\\n})\\n</code></div></pre>\\n<p>在各个应用系统请求的 <code>Header</code> 中携带 <code>Token</code> 令牌</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\">config.<span class=\\\"hljs-property\\\">headers</span>.<span class=\\\"hljs-property\\\">common</span>[<span class=\\\"hljs-string\\\">&#x27;Authorization&#x27;</span>] = <span class=\\\"hljs-string\\\">&#x27;Bearer &#x27;</span> + token\\n</code></div></pre>\\n<h3><a id=\\\"_49\\\"></a></h3>\\n');
INSERT INTO `bb_notes` VALUES ('4', 'JavaScript 继承的方式', '在 JavaScript 中，常见的几种继承方式有以下几种，让我们一起来看看吧', 'JavaScript', 'https://img.1ppt.com/uploads/allimg/1901/1_190122215801_1.JPG', '815', '0', '2022-12-08 18:34:32', '2022-12-08 18:34:32', '# JavaScript 继承的方式\\n## 1、原型继承\\n\\n实现：子类prototype指向父类的实例\\n\\n```js\\n//父\\nfunction Super(){ this.a=1 }\\nSuper.prototype.say = function(){ console.log(‘hhh’) }\\n//子\\nfunction Sub(){}\\nSub.prototype = new Super()\\n\\nconst test = new Sub()\\nconsole.log( test.say() )// hhh\\n```\\n\\n优点：通过原型继承多个引用类型的属性和方法\\n\\n缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。如下\\n\\n```js\\nfunction Super(){ this.a=[1,2] }\\nfunction Sub(){}\\nSub.prototype = new Super()\\n\\nconst test1 = new Sub()\\ntest1.a.push(3)\\nconsole.log(test1.a)// [1,2,3]\\nconst test2 = new Sub()\\nconsole.log(test2.a)// [1,2,3]\\n```\\n\\n## 2、构造函数继承\\n\\n实现：构造函数模式+call 在子类型的构造函数内部调用父类型构造函数。\\n\\n```js\\nfunction Super = function(){ this.a = 1 }\\nfunction Sub = function(){\\n       Super.call(this)\\n       this.b = 2\\n}\\n\\nconst test = new Sub()\\n```\\n\\n优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染\\n\\n缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub的实例无法访问Super原型上的方法\\n\\n## 3、组合继承\\n\\n实现：原型继承+构造函数继承\\n\\n```js\\nfunction Super(){ this.a=[1,2] }\\nSuper.prototype.say = function(){ console.log(‘hhh’) }\\nfunction Sub(){\\n    Super.call(this)\\n    this b=2\\n}\\nSub.prototype = new Super()\\n \\nconst test1 = new Sub()\\nconsole.log( test1.say() )// hhh\\ntest1.a.push(3)\\nconsole.log(test1.a)// [1,2,3]\\nconst test2 = new Sub()\\nconsole.log(test2.a)// [1,2]\\n```\\n\\n优点：集合了【原型继承】和【盗用构造函数继承】的优点\\n\\n缺点：存在效率问题，Super始终会被调用两次\\n\\n## 4、原型式继承\\n\\n实现：\\n\\nes5之前\\n\\n```js\\nconst obj = { a:1 }\\nfunction createObj(o){\\n    const Fn(){}\\n    Fn.prototype = o\\n    return new Fn()\\n}\\n\\nconst test = createObj(obj)\\n```\\n\\nes5之后\\n\\n```js\\nconst obj = { a:1 }\\n\\nconst test = Object.create(obj)\\n```\\n\\n优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性\\n\\n缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染。如下\\n\\n```js\\nconst obj = { a:[1,2], b:2 }\\nconst test1 = Object.create(obj)\\nconst test2 = Object.create(obj)\\n\\ntest1.a.push(3)\\ntest1.b=3\\nconsole.log(test1.a, test2.a)// [1,2,3]  [1,2,3]\\nconsole.log(test1.b, test2.b)// 3 2\\n```\\n\\n## 5、寄生式继承\\n\\n实现：构造函数模式+工厂模式\\n\\n```js\\nfunction createObj(o){\\n    let clone = Object.create(o)\\n    clone.say=function(){\\n        console.log(‘hhh’)\\n    }\\n    return clone\\n}\\n\\nconst obj = { a:1 }\\nconst test = createObj(obj)\\n```\\n\\n优点：根据一个对象克隆创建另一个对象，并增强对象\\n\\n缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍\\n\\n\\n\\n## 6、寄生式组合继承\\n\\n实现：盗用构造函数继承 + 原型式继承\\n\\n```js\\nfunction Super(){ this.a=[1,2] }\\nSuper.prototype.say = function(){ console.log(‘hhh’) }\\nfunction Sub(){\\n    Super.call(this)\\n    this b=2\\n}\\n\\nSub.prototype = Object.create(Super.prototype)\\nSub.prototype.constructor = Sub\\n\\nconst test = new Sub()\\n```\\n\\n优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。\\n\\n', '<h1><a id=\\\"JavaScript__0\\\"></a>JavaScript 继承的方式</h1>\\n<h2><a id=\\\"1_1\\\"></a>1、原型继承</h2>\\n<p>实现：子类prototype指向父类的实例</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-comment\\\">//父</span>\\n<span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Super</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">a</span>=<span class=\\\"hljs-number\\\">1</span> }\\n<span class=\\\"hljs-title class_\\\">Super</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span>.<span class=\\\"hljs-property\\\">say</span> = <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(‘hhh’) }\\n<span class=\\\"hljs-comment\\\">//子</span>\\n<span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Sub</span>(<span class=\\\"hljs-params\\\"></span>){}\\n<span class=\\\"hljs-title class_\\\">Sub</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span> = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Super</span>()\\n\\n<span class=\\\"hljs-keyword\\\">const</span> test = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Sub</span>()\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>( test.<span class=\\\"hljs-title function_\\\">say</span>() )<span class=\\\"hljs-comment\\\">// hhh</span>\\n</code></div></pre>\\n<p>优点：通过原型继承多个引用类型的属性和方法</p>\\n<p>缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。如下</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Super</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">a</span>=[<span class=\\\"hljs-number\\\">1</span>,<span class=\\\"hljs-number\\\">2</span>] }\\n<span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Sub</span>(<span class=\\\"hljs-params\\\"></span>){}\\n<span class=\\\"hljs-title class_\\\">Sub</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span> = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Super</span>()\\n\\n<span class=\\\"hljs-keyword\\\">const</span> test1 = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Sub</span>()\\ntest1.<span class=\\\"hljs-property\\\">a</span>.<span class=\\\"hljs-title function_\\\">push</span>(<span class=\\\"hljs-number\\\">3</span>)\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(test1.<span class=\\\"hljs-property\\\">a</span>)<span class=\\\"hljs-comment\\\">// [1,2,3]</span>\\n<span class=\\\"hljs-keyword\\\">const</span> test2 = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Sub</span>()\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(test2.<span class=\\\"hljs-property\\\">a</span>)<span class=\\\"hljs-comment\\\">// [1,2,3]</span>\\n</code></div></pre>\\n<h2><a id=\\\"2_33\\\"></a>2、构造函数继承</h2>\\n<p>实现：构造函数模式+call 在子类型的构造函数内部调用父类型构造函数。</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title class_\\\">Super</span> = <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">a</span> = <span class=\\\"hljs-number\\\">1</span> }\\n<span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title class_\\\">Sub</span> = <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>){\\n       <span class=\\\"hljs-title class_\\\">Super</span>.<span class=\\\"hljs-title function_\\\">call</span>(<span class=\\\"hljs-variable language_\\\">this</span>)\\n       <span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">b</span> = <span class=\\\"hljs-number\\\">2</span>\\n}\\n\\n<span class=\\\"hljs-keyword\\\">const</span> test = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Sub</span>()\\n</code></div></pre>\\n<p>优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染</p>\\n<p>缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub的实例无法访问Super原型上的方法</p>\\n<h2><a id=\\\"3_51\\\"></a>3、组合继承</h2>\\n<p>实现：原型继承+构造函数继承</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Super</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">a</span>=[<span class=\\\"hljs-number\\\">1</span>,<span class=\\\"hljs-number\\\">2</span>] }\\n<span class=\\\"hljs-title class_\\\">Super</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span>.<span class=\\\"hljs-property\\\">say</span> = <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(‘hhh’) }\\n<span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Sub</span>(<span class=\\\"hljs-params\\\"></span>){\\n    <span class=\\\"hljs-title class_\\\">Super</span>.<span class=\\\"hljs-title function_\\\">call</span>(<span class=\\\"hljs-variable language_\\\">this</span>)\\n    <span class=\\\"hljs-variable language_\\\">this</span> b=<span class=\\\"hljs-number\\\">2</span>\\n}\\n<span class=\\\"hljs-title class_\\\">Sub</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span> = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Super</span>()\\n \\n<span class=\\\"hljs-keyword\\\">const</span> test1 = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Sub</span>()\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>( test1.<span class=\\\"hljs-title function_\\\">say</span>() )<span class=\\\"hljs-comment\\\">// hhh</span>\\ntest1.<span class=\\\"hljs-property\\\">a</span>.<span class=\\\"hljs-title function_\\\">push</span>(<span class=\\\"hljs-number\\\">3</span>)\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(test1.<span class=\\\"hljs-property\\\">a</span>)<span class=\\\"hljs-comment\\\">// [1,2,3]</span>\\n<span class=\\\"hljs-keyword\\\">const</span> test2 = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Sub</span>()\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(test2.<span class=\\\"hljs-property\\\">a</span>)<span class=\\\"hljs-comment\\\">// [1,2]</span>\\n</code></div></pre>\\n<p>优点：集合了【原型继承】和【盗用构造函数继承】的优点</p>\\n<p>缺点：存在效率问题，Super始终会被调用两次</p>\\n<h2><a id=\\\"4_76\\\"></a>4、原型式继承</h2>\\n<p>实现：</p>\\n<p>es5之前</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">const</span> obj = { <span class=\\\"hljs-attr\\\">a</span>:<span class=\\\"hljs-number\\\">1</span> }\\n<span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">createObj</span>(<span class=\\\"hljs-params\\\">o</span>){\\n    <span class=\\\"hljs-keyword\\\">const</span> <span class=\\\"hljs-title class_\\\">Fn</span>(){}\\n    <span class=\\\"hljs-title class_\\\">Fn</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span> = o\\n    <span class=\\\"hljs-keyword\\\">return</span> <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Fn</span>()\\n}\\n\\n<span class=\\\"hljs-keyword\\\">const</span> test = <span class=\\\"hljs-title function_\\\">createObj</span>(obj)\\n</code></div></pre>\\n<p>es5之后</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">const</span> obj = { <span class=\\\"hljs-attr\\\">a</span>:<span class=\\\"hljs-number\\\">1</span> }\\n\\n<span class=\\\"hljs-keyword\\\">const</span> test = <span class=\\\"hljs-title class_\\\">Object</span>.<span class=\\\"hljs-title function_\\\">create</span>(obj)\\n</code></div></pre>\\n<p>优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性</p>\\n<p>缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染。如下</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">const</span> obj = { <span class=\\\"hljs-attr\\\">a</span>:[<span class=\\\"hljs-number\\\">1</span>,<span class=\\\"hljs-number\\\">2</span>], <span class=\\\"hljs-attr\\\">b</span>:<span class=\\\"hljs-number\\\">2</span> }\\n<span class=\\\"hljs-keyword\\\">const</span> test1 = <span class=\\\"hljs-title class_\\\">Object</span>.<span class=\\\"hljs-title function_\\\">create</span>(obj)\\n<span class=\\\"hljs-keyword\\\">const</span> test2 = <span class=\\\"hljs-title class_\\\">Object</span>.<span class=\\\"hljs-title function_\\\">create</span>(obj)\\n\\ntest1.<span class=\\\"hljs-property\\\">a</span>.<span class=\\\"hljs-title function_\\\">push</span>(<span class=\\\"hljs-number\\\">3</span>)\\ntest1.<span class=\\\"hljs-property\\\">b</span>=<span class=\\\"hljs-number\\\">3</span>\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(test1.<span class=\\\"hljs-property\\\">a</span>, test2.<span class=\\\"hljs-property\\\">a</span>)<span class=\\\"hljs-comment\\\">// [1,2,3]  [1,2,3]</span>\\n<span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(test1.<span class=\\\"hljs-property\\\">b</span>, test2.<span class=\\\"hljs-property\\\">b</span>)<span class=\\\"hljs-comment\\\">// 3 2</span>\\n</code></div></pre>\\n<h2><a id=\\\"5_116\\\"></a>5、寄生式继承</h2>\\n<p>实现：构造函数模式+工厂模式</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">createObj</span>(<span class=\\\"hljs-params\\\">o</span>){\\n    <span class=\\\"hljs-keyword\\\">let</span> clone = <span class=\\\"hljs-title class_\\\">Object</span>.<span class=\\\"hljs-title function_\\\">create</span>(o)\\n    clone.<span class=\\\"hljs-property\\\">say</span>=<span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>){\\n        <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(‘hhh’)\\n    }\\n    <span class=\\\"hljs-keyword\\\">return</span> clone\\n}\\n\\n<span class=\\\"hljs-keyword\\\">const</span> obj = { <span class=\\\"hljs-attr\\\">a</span>:<span class=\\\"hljs-number\\\">1</span> }\\n<span class=\\\"hljs-keyword\\\">const</span> test = <span class=\\\"hljs-title function_\\\">createObj</span>(obj)\\n</code></div></pre>\\n<p>优点：根据一个对象克隆创建另一个对象，并增强对象</p>\\n<p>缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍</p>\\n<h2><a id=\\\"6_139\\\"></a>6、寄生式组合继承</h2>\\n<p>实现：盗用构造函数继承 + 原型式继承</p>\\n<pre><div class=\\\"hljs\\\"><code class=\\\"lang-js\\\"><span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Super</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">this</span>.<span class=\\\"hljs-property\\\">a</span>=[<span class=\\\"hljs-number\\\">1</span>,<span class=\\\"hljs-number\\\">2</span>] }\\n<span class=\\\"hljs-title class_\\\">Super</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span>.<span class=\\\"hljs-property\\\">say</span> = <span class=\\\"hljs-keyword\\\">function</span>(<span class=\\\"hljs-params\\\"></span>){ <span class=\\\"hljs-variable language_\\\">console</span>.<span class=\\\"hljs-title function_\\\">log</span>(‘hhh’) }\\n<span class=\\\"hljs-keyword\\\">function</span> <span class=\\\"hljs-title function_\\\">Sub</span>(<span class=\\\"hljs-params\\\"></span>){\\n    <span class=\\\"hljs-title class_\\\">Super</span>.<span class=\\\"hljs-title function_\\\">call</span>(<span class=\\\"hljs-variable language_\\\">this</span>)\\n    <span class=\\\"hljs-variable language_\\\">this</span> b=<span class=\\\"hljs-number\\\">2</span>\\n}\\n\\n<span class=\\\"hljs-title class_\\\">Sub</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span> = <span class=\\\"hljs-title class_\\\">Object</span>.<span class=\\\"hljs-title function_\\\">create</span>(<span class=\\\"hljs-title class_\\\">Super</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span>)\\n<span class=\\\"hljs-title class_\\\">Sub</span>.<span class=\\\"hljs-property\\\"><span class=\\\"hljs-keyword\\\">prototype</span></span>.<span class=\\\"hljs-property\\\">constructor</span> = <span class=\\\"hljs-title class_\\\">Sub</span>\\n\\n<span class=\\\"hljs-keyword\\\">const</span> test = <span class=\\\"hljs-keyword\\\">new</span> <span class=\\\"hljs-title class_\\\">Sub</span>()\\n</code></div></pre>\\n<p>优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。</p>\\n');
INSERT INTO `bb_notes` VALUES ('5', '浏览器的垃圾回收机制', '浏览器的 Javascript 具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存，具体这是怎么实现的呢，接下来让我们一起了解一下', 'JavaScript', 'https://n.sinaimg.cn/sinacn20200202s/200/w1080h720/20200202/c0cd-intiarq1318473.jpg', '1027', '0', '2022-12-16 18:39:24', '2022-12-16 18:39:24', '# 浏览器的垃圾回收机制\\n\\n浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collection)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。\\n\\n通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用：\\n- **标记清除**：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。\\n- **引用计数**：它把**对象是否不再需要**简化定义为**对象有没有其他对象引用到它**。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。\\n\\n## 标记清除\\n\\n垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\\n\\n然后从各个根对象开始遍历，把所有在上下文中的变量以及被其引用的变量，也就是出于活跃状态的变量去除标记\\n\\n清理所有标记的变量，销毁并回收它们所占用的内存空间\\n\\n最后，重新把所有内存中的变量做上标记，等待下一轮垃圾回收\\n\\n**优点**：那就是实现比较简单\\n\\n**缺点**：就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`并造成了内存分配问题\\n\\n**内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块\\n\\n**分配速度慢**，因为即便是使用 `First-fit` 策略，其操作仍是一个 `O(n)` 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢\\n\\n假设我们新建对象分配内存时需要大小为 `size`，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 `size` 的块才能为其分配那如何找到合适的块呢？我们可以采取下面三种分配策略\\n\\n- `First-fit`，找到大于等于 `size` 的块立即返回\\n- `Best-fit`，遍历整个空闲列表，返回大于等于 `size` 的最小分块\\n- `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 `size` 大小，并将该部分返回\\n\\n这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 `First-fit` 和 `Best-fit` 来说，考虑到分配的速度和效率 `First-fit` 是更为明智的选择\\n\\n**标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存\\n\\n## 引用计数\\n记录每个变量值被使用的次数，也就是其被引用的次数\\n\\n当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\\n\\n如果同一个值又被赋给另一个变量，那么引用数加 1\\n\\n如果该变量的值被其他的值覆盖了，则引用次数减 1\\n\\n当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\\n\\n**优点** ：引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾，而标记清除算法需要每隔一段时间进行一次，JS运行过程中线程就必须要暂停去执行一段时间的垃圾回收\\n\\n标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了\\n\\n**缺点** ：需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题\\n## V8垃圾回收-新老生代\\n**分代式垃圾回收**\\n\\n上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，所以V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收\\n\\n新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大\\n\\n**新生代垃圾回收**\\n\\nCheney算法中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 `使用区`，一个是处于闲置状态的空间我们称之为`空闲区`\\n\\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作\\n\\n当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉即使用区全部清理。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区\\n\\n当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理\\n\\n另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配\\n\\n**老生代垃圾回收**\\n\\n老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间\\n\\n新生代采用并行回收  `JavaScript` 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 `JavaScript` 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 `全停顿` 并行回收指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作，这些线程同时将对象空间中的数据移动到空闲区域\\n\\n\\n**增量标记**：将一次 `GC` 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 `GC` 标记    如何实现：三色标记法   以前可以看作白色和黑色，黑色为标记（活动对象），白色为未标记，如果使用黑白进行增量标记的话，在一次标记后重新执行逻辑代码，此时白色和黑色就都有，不能区分是否标记结束， 三色标记法 白色未标记，灰色代表标记自身，但是没有标记其引用对象（成员变量），黑色都标记，第一次标记后，为灰色，开始标记它的引用对象时，变为黑色，将自身的下一个引用对象转为灰色，直到没有可标记灰色的对象时，即没有需要标记的了，白色就为需要清理的，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以\\n\\n**惰性清理**：增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 `JavaScript` 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记\\n\\n**并发回收**：它指的是主线程在执行 `JavaScript` 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起 需要考虑主线程在执行 `JavaScript `时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点\\n\\n', '<h1><a id=\\\"_0\\\"></a>浏览器的垃圾回收机制</h1>\\n<p>浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collection)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>\\n<p>通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用：</p>\\n<ul>\\n<li><strong>标记清除</strong>：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</li>\\n<li><strong>引用计数</strong>：它把<strong>对象是否不再需要</strong>简化定义为<strong>对象有没有其他对象引用到它</strong>。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li>\\n</ul>\\n<h2><a id=\\\"_8\\\"></a>标记清除</h2>\\n<p>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</p>\\n<p>然后从各个根对象开始遍历，把所有在上下文中的变量以及被其引用的变量，也就是出于活跃状态的变量去除标记</p>\\n<p>清理所有标记的变量，销毁并回收它们所占用的内存空间</p>\\n<p>最后，重新把所有内存中的变量做上标记，等待下一轮垃圾回收</p>\\n<p><strong>优点</strong>：那就是实现比较简单</p>\\n<p><strong>缺点</strong>：就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 <code>内存碎片</code>并造成了内存分配问题</p>\\n<p><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</p>\\n<p><strong>分配速度慢</strong>，因为即便是使用 <code>First-fit</code> 策略，其操作仍是一个 <code>O(n)</code> 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢</p>\\n<p>假设我们新建对象分配内存时需要大小为 <code>size</code>，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 <code>size</code> 的块才能为其分配那如何找到合适的块呢？我们可以采取下面三种分配策略</p>\\n<ul>\\n<li><code>First-fit</code>，找到大于等于 <code>size</code> 的块立即返回</li>\\n<li><code>Best-fit</code>，遍历整个空闲列表，返回大于等于 <code>size</code> 的最小分块</li>\\n<li><code>Worst-fit</code>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 <code>size</code> 大小，并将该部分返回</li>\\n</ul>\\n<p>这三种策略里面 <code>Worst-fit</code> 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 <code>First-fit</code> 和 <code>Best-fit</code> 来说，考虑到分配的速度和效率 <code>First-fit</code> 是更为明智的选择</p>\\n<p><strong>标记整理（Mark-Compact）算法</strong> 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存</p>\\n<h2><a id=\\\"_36\\\"></a>引用计数</h2>\\n<p>记录每个变量值被使用的次数，也就是其被引用的次数</p>\\n<p>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</p>\\n<p>如果同一个值又被赋给另一个变量，那么引用数加 1</p>\\n<p>如果该变量的值被其他的值覆盖了，则引用次数减 1</p>\\n<p>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</p>\\n<p><strong>优点</strong> ：引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾，而标记清除算法需要每隔一段时间进行一次，JS运行过程中线程就必须要暂停去执行一段时间的垃圾回收</p>\\n<p>标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了</p>\\n<p><strong>缺点</strong> ：需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题</p>\\n<h2><a id=\\\"V8_52\\\"></a>V8垃圾回收-新老生代</h2>\\n<p><strong>分代式垃圾回收</strong></p>\\n<p>上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，所以V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收</p>\\n<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 <code>1～8M</code> 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大</p>\\n<p><strong>新生代垃圾回收</strong></p>\\n<p>Cheney算法中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 <code>使用区</code>，一个是处于闲置状态的空间我们称之为<code>空闲区</code></p>\\n<p>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作</p>\\n<p>当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉即使用区全部清理。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区</p>\\n<p>当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理</p>\\n<p>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 <code>Scavenge</code> 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配</p>\\n<p><strong>老生代垃圾回收</strong></p>\\n<p>老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间</p>\\n<p>新生代采用并行回收  <code>JavaScript</code> 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 <code>JavaScript</code> 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 <code>全停顿</code> 并行回收指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作，这些线程同时将对象空间中的数据移动到空闲区域</p>\\n<p><strong>增量标记</strong>：将一次 <code>GC</code> 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 <code>GC</code> 标记    如何实现：三色标记法   以前可以看作白色和黑色，黑色为标记（活动对象），白色为未标记，如果使用黑白进行增量标记的话，在一次标记后重新执行逻辑代码，此时白色和黑色就都有，不能区分是否标记结束， 三色标记法 白色未标记，灰色代表标记自身，但是没有标记其引用对象（成员变量），黑色都标记，第一次标记后，为灰色，开始标记它的引用对象时，变为黑色，将自身的下一个引用对象转为灰色，直到没有可标记灰色的对象时，即没有需要标记的了，白色就为需要清理的，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以</p>\\n<p><strong>惰性清理</strong>：增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 <code>JavaScript</code> 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记</p>\\n<p><strong>并发回收</strong>：它指的是主线程在执行 <code>JavaScript</code> 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起 需要考虑主线程在执行 <code>JavaScript </code>时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点</p>\\n');
INSERT INTO `bb_notes` VALUES ('6', '为何0.1+0.2 !== 0.3', '在学习JavaScript的时候，经常会遇到这样的情况：你在控制台输入0.1+0.2，结果不应该是0.3吗，可打印出来的却是0.30000000000000004，这究竟是什么原因？', 'JavaScript', 'https://img.1ppt.com/uploads/allimg/1305/1-13052FS639112.jpg', '4268', '7', '2022-12-21 14:40:35', '2022-12-21 14:40:35', '# 为何0.1+0.2 !== 0.3\\n\\nJavaScript 的数字是 IEEE-754 标准存储的双精度浮点数类型。双精度浮点数总共有 64 位（bit），第一位用于表示符号，接着十一位用于表示阶码（指数），剩余的五十二位用于表示尾数（小数）\\n\\n根据公式尾码表示的是小数点后面的部分，整数部分永远是 1。这是因为对于任意一个非零数字，第一位有效数字肯定是 1 。所以一般第一个 1 **不需要存**。因此，JavaScript提供的有效数字最长为53个二进制位（52位+省略的1位）\\n\\n## 原因总结\\n\\n原因总结：\\n\\n\\n\\n- `进制转换` ：js 在进行浮点数计算的时候，0.1 和 0.2 都会转成无限循环的二进制，因为 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，大于 53 位后面的会全部截掉，导致精度丢失。\\n- `对阶运算` ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（`0舍1入`），尾数位移时可能会发生数丢失的情况，影响精度。\\n\\n小数使用的方式是**乘二取整**法，小数 0.125 转成二进制的过程： 十进制 0.125 的二进制形式是 `0.001` \\n\\n```\\n0.125 * 2 => 0.25, 0\\n0.25 * 2 => 0.5, 0\\n0.5 * 2 => 1, 1\\n```\\n\\n\\n十进制 `0.1` 用二进制怎么表示。\\n```\\n0.1 * 2 => 0.2, 0\\n0.2 * 2 => 0.4, 0\\n0.4 * 2 => 0.8, 0\\n0.8 * 2 => 1.6, 1\\n0.6 * 2 => 1.2, 1\\n0.2 * 2 => 0.4, 0\\n...\\n```\\n`0.00011001100110011...`， 出现了 `0011` 的无限循环，第一个有效数字1出现在小数点后第四位，把它往前移动四位，阶码为 -4，符号位为 0，得到 0.1 的二进制形式：\\n```\\n0 01111111011 1001100110011001100110011001100110011001100110011010\\n```\\n0.2 是 0.1 的两倍，尾码保持不动，阶码 + 1，得到 0.2 的二进制形式：\\n```\\n0 01111111100 1001100110011001100110011001100110011001100110011010\\n```\\n到这里，我们知道了，数字0.1，0.2 在js中，本身就存在`精度丢失`，再拿这两个数进行加浮运算: 0.2 的阶码比 0.1 的阶码大一，把 0.1 的尾码右移一位，阶码加 1，让两个数的阶码保持一致。\\n```\\n  0 01111111100  0.1100110011001100110011001100110011001100110011001101\\n+ 0 01111111100  1.1001100110011001100110011001100110011001100110011010\\n= 0 01111111100 10.0110011001100110011001100110011001100110011001100111\\n```\\n把运算结果按照 IEEE-754 标准格式化，需要向右移动一位，阶码加一。但是最后一个 1 放不下了，需要舍弃，根据标准当要舍弃一位数时，需要进行0舍1入。如果被舍弃的是 0 什么都不用做，如果被舍弃的是1，则需要补回来。\\n```\\n0 01111111101 0011001100110011001100110011001100110011001100110011 1（1 多出，需要舍弃）\\n0 01111111101 0011001100110011001100110011001100110011001100110100  （补 1）\\n```\\n于是，0.1 + 0.2 的运算结果为：\\n```\\n0 01111111101 0011001100110011001100110011001100110011001100110100\\n```\\n同样方法再算一下 0.3 的二进制\\n```\\n0.3 * 2 => 0.6, 0\\n0.6 * 2 => 1.2, 1\\n0.2 * 2 => 0.4, 0\\n0.4 * 2 => 0.8, 0\\n0.8 * 2 => 1.6, 1\\n0.6 * 2 => 1.2, 1\\n...\\n```\\n一样出现了循环 0011，第一个数字 1 出现在第二位，尾码往前移动两位，阶码为 -2。所以 0.3 的二进制形式如下：\\n```\\n0 01111111101 0011001100110011001100110011001100110011001100110011\\n```\\n和 0.1 + 0.2 的运算结果比较确实不相等，至此我们明白了**进制转换**与**对阶运算**都会导致浮点数计算的精度缺失问题\\n\\n## 解决办法\\n1.转为整数（大数）运算\\n2. 使用 `Number.EPSILON` 误差范围\\n3. 转成字符串，对字符串做加法运算。\\n\\n\\n', '<h1><a id=\\\"0102__03_0\\\"></a>为何0.1+0.2 !== 0.3</h1>\\n<p>JavaScript 的数字是 IEEE-754 标准存储的双精度浮点数类型。双精度浮点数总共有 64 位（bit），第一位用于表示符号，接着十一位用于表示阶码（指数），剩余的五十二位用于表示尾数（小数）</p>\\n<p>根据公式尾码表示的是小数点后面的部分，整数部分永远是 1。这是因为对于任意一个非零数字，第一位有效数字肯定是 1 。所以一般第一个 1 <strong>不需要存</strong>。因此，JavaScript提供的有效数字最长为53个二进制位（52位+省略的1位）</p>\\n<h2><a id=\\\"_6\\\"></a>原因总结</h2>\\n<p>原因总结：</p>\\n<ul>\\n<li><code>进制转换</code> ：js 在进行浮点数计算的时候，0.1 和 0.2 都会转成无限循环的二进制，因为 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，大于 53 位后面的会全部截掉，导致精度丢失。</li>\\n<li><code>对阶运算</code> ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（<code>0舍1入</code>），尾数位移时可能会发生数丢失的情况，影响精度。</li>\\n</ul>\\n<p>小数使用的方式是<strong>乘二取整</strong>法，小数 0.125 转成二进制的过程： 十进制 0.125 的二进制形式是 <code>0.001</code></p>\\n<pre><code class=\\\"lang-\\\">0.125 * 2 =&gt; 0.25, 0\\n0.25 * 2 =&gt; 0.5, 0\\n0.5 * 2 =&gt; 1, 1\\n</code></pre>\\n<p>十进制 <code>0.1</code> 用二进制怎么表示。</p>\\n<pre><code class=\\\"lang-\\\">0.1 * 2 =&gt; 0.2, 0\\n0.2 * 2 =&gt; 0.4, 0\\n0.4 * 2 =&gt; 0.8, 0\\n0.8 * 2 =&gt; 1.6, 1\\n0.6 * 2 =&gt; 1.2, 1\\n0.2 * 2 =&gt; 0.4, 0\\n...\\n</code></pre>\\n<p><code>0.00011001100110011...</code>， 出现了 <code>0011</code> 的无限循环，第一个有效数字1出现在小数点后第四位，把它往前移动四位，阶码为 -4，符号位为 0，得到 0.1 的二进制形式：</p>\\n<pre><code class=\\\"lang-\\\">0 01111111011 1001100110011001100110011001100110011001100110011010\\n</code></pre>\\n<p>0.2 是 0.1 的两倍，尾码保持不动，阶码 + 1，得到 0.2 的二进制形式：</p>\\n<pre><code class=\\\"lang-\\\">0 01111111100 1001100110011001100110011001100110011001100110011010\\n</code></pre>\\n<p>到这里，我们知道了，数字0.1，0.2 在js中，本身就存在<code>精度丢失</code>，再拿这两个数进行加浮运算: 0.2 的阶码比 0.1 的阶码大一，把 0.1 的尾码右移一位，阶码加 1，让两个数的阶码保持一致。</p>\\n<pre><code class=\\\"lang-\\\">  0 01111111100  0.1100110011001100110011001100110011001100110011001101\\n+ 0 01111111100  1.1001100110011001100110011001100110011001100110011010\\n= 0 01111111100 10.0110011001100110011001100110011001100110011001100111\\n</code></pre>\\n<p>把运算结果按照 IEEE-754 标准格式化，需要向右移动一位，阶码加一。但是最后一个 1 放不下了，需要舍弃，根据标准当要舍弃一位数时，需要进行0舍1入。如果被舍弃的是 0 什么都不用做，如果被舍弃的是1，则需要补回来。</p>\\n<pre><code class=\\\"lang-\\\">0 01111111101 0011001100110011001100110011001100110011001100110011 1（1 多出，需要舍弃）\\n0 01111111101 0011001100110011001100110011001100110011001100110100  （补 1）\\n</code></pre>\\n<p>于是，0.1 + 0.2 的运算结果为：</p>\\n<pre><code class=\\\"lang-\\\">0 01111111101 0011001100110011001100110011001100110011001100110100\\n</code></pre>\\n<p>同样方法再算一下 0.3 的二进制</p>\\n<pre><code class=\\\"lang-\\\">0.3 * 2 =&gt; 0.6, 0\\n0.6 * 2 =&gt; 1.2, 1\\n0.2 * 2 =&gt; 0.4, 0\\n0.4 * 2 =&gt; 0.8, 0\\n0.8 * 2 =&gt; 1.6, 1\\n0.6 * 2 =&gt; 1.2, 1\\n...\\n</code></pre>\\n<p>一样出现了循环 0011，第一个数字 1 出现在第二位，尾码往前移动两位，阶码为 -2。所以 0.3 的二进制形式如下：</p>\\n<pre><code class=\\\"lang-\\\">0 01111111101 0011001100110011001100110011001100110011001100110011\\n</code></pre>\\n<p>和 0.1 + 0.2 的运算结果比较确实不相等，至此我们明白了<strong>进制转换</strong>与<strong>对阶运算</strong>都会导致浮点数计算的精度缺失问题</p>\\n<h2><a id=\\\"_73\\\"></a>解决办法</h2>\\n<p>1.转为整数（大数）运算<br />\\n2. 使用 <code>Number.EPSILON</code> 误差范围<br />\\n3. 转成字符串，对字符串做加法运算。</p>\\n');

-- ----------------------------
-- Table structure for bb_note_comment
-- ----------------------------
DROP TABLE IF EXISTS `bb_note_comment`;
CREATE TABLE `bb_note_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `pid` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  `note_id` int(11) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT '',
  `below_reply_id` int(11) DEFAULT NULL,
  `below_reply_name` varchar(255) DEFAULT '',
  `user_pic` text,
  `content` varchar(255) DEFAULT '',
  `create_date` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `note_id` (`note_id`),
  CONSTRAINT `bb_note_comment_ibfk_1` FOREIGN KEY (`note_id`) REFERENCES `bb_notes` (`note_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bb_note_comment
-- ----------------------------
INSERT INTO `bb_note_comment` VALUES ('1', '-1', '1', '6', '秃头熊', null, null, 'http://localhost:3008/static/uploads/1675240793946.jpeg', '很好', '2023-01-01 02:20:16');
INSERT INTO `bb_note_comment` VALUES ('2', '-1', '222', '6', '自信的小孩', null, null, 'https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg', '原来是这么回事，终于弄懂了[泪]', '2023-01-04 10:17:00');
INSERT INTO `bb_note_comment` VALUES ('3', '2', '333', '6', '努力的前端er', null, null, 'https://img2.baidu.com/it/u=913120302,1224843975&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '我也，之前一直弄不明', '2023-01-05 17:21:57');
INSERT INTO `bb_note_comment` VALUES ('4', '2', '444', '6', '我是牛牛我怕谁', null, '努力的前端er', 'https://img2.baidu.com/it/u=3438509800,1917053388&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '哈哈哈，我也是', '2023-01-05 22:26:00');
INSERT INTO `bb_note_comment` VALUES ('10', '2', '1', '6', '秃头熊', '4', '我是牛牛我怕谁', 'http://localhost:3008/static/uploads/1675240793946.jpeg', '我一开始也不明白', '2023-01-31 15:24:34');
INSERT INTO `bb_note_comment` VALUES ('11', '2', '444', '6', '我是牛牛我怕谁', '10', '秃头熊', 'https://img2.baidu.com/it/u=3438509800,1917053388&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500', '嘿嘿嘿', '2023-01-31 15:44:32');

-- ----------------------------
-- Table structure for bb_users
-- ----------------------------
DROP TABLE IF EXISTS `bb_users`;
CREATE TABLE `bb_users` (
  `uid` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) DEFAULT '',
  `password` varchar(255) DEFAULT '',
  `nickname` varchar(255) DEFAULT '',
  `email` varchar(255) DEFAULT '',
  `phone` varchar(255) DEFAULT '',
  `user_pic` text,
  `role` int(11) DEFAULT NULL,
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of bb_users
-- ----------------------------
INSERT INTO `bb_users` VALUES ('1', 'admin', '$2a$10$AT1/NZPBcaZ7E2bZxS0PFeVnpBznnEkH4gtZvEsSr79hitGXKJBEy', '秃头熊', 'admin@admin.com', '12345678900', 'http://localhost:3008/static/uploads/1675240793946.jpeg', '1');
INSERT INTO `bb_users` VALUES ('2', 'test', '$2a$10$tSsnjfy6ZCcvso7AzJC0Z.5KBPAOBmsdU/eiYC4pEm.5fWI/zKZTW', '用户eK351dZe', 'test@test.com', '12345678900', '1675240793946.jpeg', '0');
DROP TRIGGER IF EXISTS `update_message_user_pic`;
DELIMITER ;;
CREATE TRIGGER `update_message_user_pic` AFTER UPDATE ON `bb_users` FOR EACH ROW BEGIN
    UPDATE bb_message SET user_pic = new.user_pic,nickname = new.nickname
    WHERE user_id = old.uid;
END
;;
DELIMITER ;
DROP TRIGGER IF EXISTS `update_note_user_pic`;
DELIMITER ;;
CREATE TRIGGER `update_note_user_pic` AFTER UPDATE ON `bb_users` FOR EACH ROW BEGIN
    UPDATE bb_note_comment SET user_pic = new.user_pic,nickname = new.nickname
    WHERE user_id = old.uid;
END
;;
DELIMITER ;
